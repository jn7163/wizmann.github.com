<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Maerlyn's Rainbow - Wizmann</title><link>http://wizmann.tk/</link><description></description><lastBuildDate>Wed, 26 Jul 2017 00:00:00 +0800</lastBuildDate><item><title>Metaprogramming in .NET 读书笔记 - 1</title><link>http://wizmann.tk/metaprogramming-in-dotnet-1.html</link><description>&lt;h2&gt;什么是 Metaprogramming (元编程)&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="http://wizmann-pic.qiniudn.com/17-2-15/1418894-file_1487139497158_1868c.jpg"&gt;&lt;/p&gt;
&lt;p&gt;元编程从字面上理解就是“能处理程序的程序”。&lt;/p&gt;
&lt;p&gt;这里的“处理”，有两个意思。&lt;/p&gt;
&lt;p&gt;一是“编写”、“生成”，最经典例子就是编译器，它将我们的所编写的高级语言翻译成机器代码。编译器就像建筑工人，将“蓝图”（高级语言）转化成“高楼大厦”（机器语言）。还有一个我们经常用到的就是“宏”(Macro)。我们可以在代码中使用预先编写好的宏，在编译期，宏会被自动展开成相应的代码。这样的好处是用机器带替人类劳动。&lt;/p&gt;
&lt;p&gt;“处理”的另外一个意思就是“处理自己”，元编程让程序在运行时了解自己的状态，并动态的扩展并执行的相应逻辑。&lt;/p&gt;
&lt;p&gt;当然，最高级的“处理”就是能完全代替人脑的人工智能。如果那一天到来，我们就距离生活在Matrix里不远了。&lt;/p&gt;
&lt;h2&gt;元编程的实现&lt;/h2&gt;
&lt;p&gt;元编程主要实现在编译期前后以及运行时。&lt;/p&gt;
&lt;p&gt;元编程主要依赖于以下技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码生成(code generation)&lt;/li&gt;
&lt;li&gt;反射(reflection)&lt;/li&gt;
&lt;li&gt;汇编重写(assembly rewriting)&lt;/li&gt;
&lt;li&gt;表达式 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Wed, 26 Jul 2017 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2017-07-26:/metaprogramming-in-dotnet-1.html</guid><category>Metaprogramming</category><category>.NET</category><category>C#</category></item><item><title>Why do I quit Leetcode contest?</title><link>http://wizmann.tk/why-do-i-quit-leetcode-contest.html</link><description>&lt;h2&gt;Foreword&lt;/h2&gt;
&lt;p&gt;The title is quite "Yin-ish" as it seems, but I'm not a "Yin-ist". You know what I mean.&lt;/p&gt;
&lt;h2&gt;Why I quit?&lt;/h2&gt;
&lt;p&gt;I did a quite a good job in Leetcode Weekly Contest, at least in my point of view. I won a 4th place and a 6th place in …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Wed, 07 Jun 2017 01:53:42 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2017-06-07:/why-do-i-quit-leetcode-contest.html</guid><category>leetcode</category></item><item><title>STUP - the Implementation (3)</title><link>http://wizmann.tk/stup-3.html</link><description>&lt;h2&gt;throughput and window size&lt;/h2&gt;
&lt;p&gt;The wisdom of STUP protocol is all about the window size. The throughput of a TCP communication is limited by two windows: the congestion window and the receive window. The congestion window can determine how many bytes that can be send a simple piece of time …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Mon, 08 May 2017 22:15:58 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2017-05-08:/stup-3.html</guid><category>STUP</category><category>TCP</category><category>UDP</category><category>networking</category><category>protocol</category></item><item><title>STUP - Packet Structure and State Machine (2)</title><link>http://wizmann.tk/stup-2.html</link><description>&lt;h2&gt;STUP Packet Structure&lt;/h2&gt;
&lt;h3&gt;Brief Introduction of TCP &amp;amp; UDP Packet Structure&lt;/h3&gt;
&lt;p&gt;&lt;img alt="" src="http://wizmann-pic.qiniudn.com/17-4-24/73808256-file_1493006773118_a335.png"&gt;&lt;/p&gt;
&lt;p&gt;STUP pretend itself as a protocol at the Transmission Layer, but actually it's absolutely an Application Layer protocol. So before we start, I'd like to recall some knowledge of two important Transmission Layer protocol: TCP &amp;amp; UDP.&lt;/p&gt;
&lt;p&gt;It is well known …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Thu, 04 May 2017 00:53:03 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2017-05-04:/stup-2.html</guid><category>STUP</category><category>TCP</category><category>UDP</category><category>networking</category><category>protocol</category></item><item><title>STUP - another (stupid) TCP over UDP protocol (1)</title><link>http://wizmann.tk/stup-1.html</link><description>&lt;h2&gt;What is STUP?&lt;/h2&gt;
&lt;p&gt;STUP is the abbreviation of "Speeded/Secure Tcp-like Udp Protocol", which means that it's another TCP over UDP protocol.&lt;/p&gt;
&lt;p&gt;Why TCP over UDP?&lt;/p&gt;
&lt;p&gt;TCP is a network protocol for general purpose, and it's one of the most commonly used internet protocol on this planet. It is reliable …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Thu, 20 Apr 2017 23:17:45 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2017-04-20:/stup-1.html</guid><category>STUP</category><category>TCP</category><category>UDP</category><category>networking</category><category>protocol</category></item><item><title>WorkflowyMd Release Note</title><link>http://wizmann.tk/workflowymd.html</link><description>&lt;h2&gt;What is it?&lt;/h2&gt;
&lt;p&gt;I've writen several workflowy enhance plugins by UserScript. The very first one is show the full content of the note of a bullet. The second one is to show images under the bullet. Then I worked on the background image to make a more colorful workflowy.&lt;/p&gt;
&lt;p&gt;Yeah …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Thu, 26 Jan 2017 21:07:28 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2017-01-26:/workflowymd.html</guid><category>workflowy</category><category>userscript</category></item><item><title>Parallel patterns in C#</title><link>http://wizmann.tk/parallel-in-csharp.html</link><description>&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;与C/C++所使用的，传统的基于线程的并行模式不同，C#实现了丰富的并发编程模型，其中以异步模型最为流行。&lt;/p&gt;
&lt;p&gt;本文中我们重点讨论C#在发展过程中出现的几种异步编程模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Async Programming Model（APM）&lt;/li&gt;
&lt;li&gt;Event-based Async Pattern (EAP)&lt;/li&gt;
&lt;li&gt;Task-based Async Pattern（TAP）&lt;/li&gt;
&lt;li&gt;async/await语法糖&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;异步编程入门&lt;/h2&gt;
&lt;p&gt;同步模式是最常见，也是最被人熟知的编程模型，每一个任务按顺序执行，前一个任务执行完之后才会执行下一个任务。&lt;/p&gt;
&lt;p&gt;异步编程和同步编程不同，程序的执行流程是由“事件”所驱动的。异步编程有两种实现方式，回调与future模式。&lt;/p&gt;
&lt;p&gt;回调函数在Javascript中被大量使用，相信大家也都不会陌生。但是大量的回调函数会让代码失去可读性，陷入“Callback hell”。&lt;/p&gt;
&lt;p&gt;Promise模式是回调函数的一种“包装”。我们使用一个占位符来表示“未来”将会产生的一个异步处理结果。&lt;/p&gt;
&lt;p&gt;这个占位符在不同的语言/框架里面有不同的名字，其定义也不尽相同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Task …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sun, 22 Jan 2017 22:52:28 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2017-01-22:/parallel-in-csharp.html</guid><category>csharp</category><category>parallel</category><category>thread</category><category>async</category></item><item><title>Twisted Defer and DeferredQueue</title><link>http://wizmann.tk/twisted-defer-and-deferredqueue.html</link><description>&lt;h2&gt;写在最前面&lt;/h2&gt;
&lt;p&gt;这篇文章本来是想用英文写的，但是最近英文水平下降的和狗一样。还是怂一波吧。&lt;/p&gt;
&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;最近在用Twisted库写一个诡异的项目，具体内容暂且不在这里讨论。在写的过程中，被Twisted里面的一个重要概念 —— defer，折腾的不行。最终通过阅读twisted的部分源码，以及与代码做斗争的丰富经验，最终算是解决了问题。&lt;/p&gt;
&lt;p&gt;本文算是使用twisted开发踩坑的一个小小总结，如果一切顺利，后面会有大菜。：）&lt;/p&gt;
&lt;h2&gt;Twisted介绍&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Twisted is an event-driven networking engine written in Python.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Twisted是一个基于事件驱动的网络框架。那么什么是“事件驱动”呢？&lt;/p&gt;
&lt;p&gt;事件驱动指的是将事件与事件回调绑定起来，在程序运行时根据实时的事件触发相应的响应的一种机制。&lt;/p&gt;
&lt;p&gt;例如select/poll/epoll这些IO复用函数，在文件描述符（fd）可读/可写/出错时，会立即返回，由相应的处理函数来对新事件进行处理。事实上，twisted的事件驱动功能，正是由这些IO复用函数提供的。&lt;/p&gt;
&lt;p&gt;但与IO复用函数不同的是，twisted中的事件可以是“更高层次的事件”，即对网络的读 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sat, 10 Dec 2016 11:34:38 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2016-12-10:/twisted-defer-and-deferredqueue.html</guid><category>twisted</category><category>defer</category><category>async</category></item><item><title>Mosca源码阅读</title><link>http://wizmann.tk/mosca.html</link><description>&lt;h2&gt;先在前面&lt;/h2&gt;
&lt;p&gt;最近心血来潮看了看一个比较有名的开源MQTT broker —— Mosca。不读不知道，读完才恍然大悟 —— 这是啥破玩意（哈哈）。&lt;/p&gt;
&lt;p&gt;由于我是nodejs的超级初学者，所以本文会比较浅显，并且只关注big picture，不陷入细节。&lt;/p&gt;
&lt;p&gt;这里先规定几个缩写，让后面行文时少打一点字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MQ - MessageQueue&lt;/li&gt;
&lt;li&gt;Asco - Ascoltatori&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Ascoltatori - 听者&lt;/h2&gt;
&lt;p&gt;Ascoltatori是一个意大利语单词，翻译成英文就是listener。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里严重吐槽作者取名字的方式，mosca这种短小的外语单词我们是可以接受的，你说ascoltatori这么长的意大利语单词，你让我们怎么记。    &lt;br&gt;
差评，退款，邮费也要退！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Asco模块的作用是提供一个一致的MQ的抽象，供上层broker使用。&lt;/p&gt;
&lt;p&gt;这里我们只分析基于Redis的实现，原因是Redis我相对比较熟悉，功能也比较简单。&lt;/p&gt;
&lt;h3&gt;接口分析&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;RedisAscoltatore&lt;/code&gt;有三个半接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;subscribe&lt;/li&gt;
&lt;li&gt;unsubscribe&lt;/li&gt;
&lt;li&gt;publish&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;剩下的那半个是模块的构造函数。接下来我们分别分析接口的功能及其实现。&lt;/p&gt;
&lt;h3&gt;Subscribe接口&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;this._sub&lt;/code&gt;是&lt;code&gt;RedisAscoltatore&lt;/code&gt;用来subscribe的连接。首先我们要向MQ订阅指定的topic …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Fri, 11 Nov 2016 22:04:13 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2016-11-11:/mosca.html</guid><category>mosca</category><category>mq</category><category>message queue</category></item><item><title>总结 - phxrpc代码阅读(8)</title><link>http://wizmann.tk/phxrpc-8.html</link><description>&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;这应该是phxrpc代码阅读系列正文的最后一篇。通过阅读代码，发现了自己在知识上的若干不足。&lt;/p&gt;
&lt;p&gt;临渊羡鱼，不如退而结网。接下来可能会在网络编程方面再下一点工夫。请大家期待下一个系列吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实真没人读，我就是在骗自己。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;先补充一点 - 代码生成&lt;/h2&gt;
&lt;p&gt;protobuf并不包含RPC的实现，但是它可以声明rpc。客户端和服务端需要实现RPC接口，来实现通信。&lt;/p&gt;
&lt;p&gt;phxrpc使用proto文件来定义接口，然后解析并使用代码模板进行生成。&lt;/p&gt;
&lt;p&gt;这里我们不讨论代码生成的细节，因为pb实在太过流行，代码生成的方法也有不少的流派。并且用C++来做代码生成，真心不是我的菜。&lt;/p&gt;
&lt;p&gt;想了解更多，可以参考&lt;a href="http://codemacro.com/2014/08/31/protobuf-rpc/"&gt;这篇博客&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;工作流程 - 客户端&lt;/h2&gt;
&lt;p&gt;客户端与服务器的通信有如下的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;连接少&lt;/li&gt;
&lt;li&gt;负载少&lt;/li&gt;
&lt;li&gt;通信的主动方&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，所有的网络交互相关的内容可以托管给网络库中的协程。每个协程主动运行一段时间后，主动放弃CPU时间，将控制权交还给主控制流的epoll。&lt;/p&gt;
&lt;p&gt;所以协程中不能有CPU密集的运算，幸好面对开发者，phxrpc并不暴露内部函数，而是将CPU密集的运算分配给工作线程来完成。&lt;/p&gt;
&lt;h2&gt;工作流程 - 服务端&lt;/h2&gt;
&lt;p&gt;服务器的通信有以下的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;连接多&lt;/li&gt;
&lt;li&gt;负载多&lt;/li&gt;
&lt;li&gt;通信的被动方&lt;/li&gt;
&lt;li&gt;响应时间敏感&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里说一下响应时间的问题 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sun, 23 Oct 2016 15:50:44 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2016-10-23:/phxrpc-8.html</guid><category>phxrpc</category><category>rpc</category></item><item><title>RPC - phxrpc代码阅读(7)</title><link>http://wizmann.tk/phxrpc-7.html</link><description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;看了这么久代码，终于我们要接近phxrpc的核心部分了。&lt;/p&gt;
&lt;p&gt;但是出人意料的是，rpc部分并没有过多的概念和magic trick。而且因为ucontext已经被封装好了，所以在rpc里的操作，可以完全按照同步的写法来搞，开发者们不需要切换同步异步的思维模式，就可以在底层的封装之上，做自己想做的事了。&lt;/p&gt;
&lt;h2&gt;线程安全(?)的队列 - ThreadQueue&lt;/h2&gt;
&lt;p&gt;我不知道开发者为啥要起&lt;code&gt;ThdQueue&lt;/code&gt;这样令人迷惑的名字，这种诡异的命名风格贯穿了整个代码。咋一看这个类是maintain一堆线程的，类似于线程池，但其实这个类就是一个&lt;code&gt;BlockingQueue&lt;/code&gt;的实现。&lt;/p&gt;
&lt;p&gt;之后，这个队列有三种操作，&lt;code&gt;push&lt;/code&gt;、&lt;code&gt;pluck&lt;/code&gt;和&lt;code&gt;break_out&lt;/code&gt;。push操作不用多说，pluck对应的我们所理解的pop操作，即从队列中弹出元素（pluck这个词貌似是从grpc里面来的，那我就不吐槽了，毕竟Google爸爸）。&lt;/p&gt;
&lt;p&gt;更令人疑惑的是&lt;code&gt;break_out&lt;/code&gt;这个操作。从代码来看，像是清空队列，并且在dtor中也显式的调用了这个函数。&lt;/p&gt;
&lt;p&gt;但是有以下的几个问题。&lt;/p&gt;
&lt;p&gt;一，&lt;code&gt;break_out_&lt;/code&gt;是一个bool变量，且在不同线程间共享，问题在于这个变量可能被cache住，直接访问可能会造成非预期的结果，可能需要 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sat, 22 Oct 2016 23:03:36 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2016-10-22:/phxrpc-7.html</guid><category>phxrpc</category><category>rpc</category></item><item><title>非阻塞TCP流和HttpClient - phxrpc代码阅读(6)</title><link>http://wizmann.tk/phxrpc-6.html</link><description>&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;其实这点东西有点鸡肋。因为TCP流在前面已经讲过，难点在于“流”和“流缓冲区”部分。而HttpClient只是TCP流的一个应用，代码不多，且重点在于HTTP协议的调教上面。&lt;/p&gt;
&lt;p&gt;不过因为前面有写阻塞TCP流，还是前后呼应，把非阻塞TCP流也小小的讲解一下。顺便饶一段HttpClient的讲解，算是充实一下内容吧。&lt;/p&gt;
&lt;h2&gt;非阻塞TCP流缓冲区 - &lt;code&gt;UThreadTcpStreamBuf&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;这个其实没啥可讲的，传入一个&lt;code&gt;socket&lt;/code&gt;，然后读写分别调用&lt;code&gt;UThreadRecv&lt;/code&gt;和&lt;code&gt;UThreadSend&lt;/code&gt;，IO复用和协程切换的复杂操作都被封装在里面了。剩下的操作都由基类函数来解决。&lt;/p&gt;
&lt;h2&gt;非阻塞TCP流 - &lt;code&gt;UThreadTcpStream&lt;/code&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;确实没啥可说的，你们自己去读代码吧。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;非阻塞TCP流和阻塞TCP流的区别是~~它不阻塞~~，在阻塞TCP流中，我们传入的是一个TCP流，而非阻塞TCP流传入的是一个协程调度器和一个TCP流。&lt;/p&gt;
&lt;p&gt;这个很好理解，一个阻塞流自然会占满一个线程的IO和CPU —— 在阻塞流IO读写时，CPU空闲；在CPU忙时，IO空闲。&lt;/p&gt;
&lt;p&gt;而非阻塞流会将自己IO wait的时间托管给epoll，把剩下的时间用于CPU计算（和一些overhead上）。所以一个线程可以handle多个socket，协程调度器就是必须的了。之后的读写操作就交由我们前面讨论过的epoll和ucontext协程来共同完成了。&lt;/p&gt;
&lt;h2&gt;HttpClient …&lt;/h2&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Wed, 19 Oct 2016 00:03:12 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2016-10-19:/phxrpc-6.html</guid><category>phxrpc</category></item><item><title>使用epoll驱动ucontext - phxrpc代码阅读(5)</title><link>http://wizmann.tk/phxrpc-5.html</link><description>&lt;h2&gt;用pipe叫醒你 — EpollNotifier&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;class EpollNotifier&lt;/code&gt;类型封装了一个使用pipe传递信号的Notifier类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Run()&lt;/code&gt;函数（其实我觉得叫Register或Activate会更好）首先声明了两个单向的pipe：&lt;code&gt;pipe_fds_&lt;/code&gt;，从&lt;a href="http://man7.org/linux/man-pages/man2fpipe.2.html"&gt;文档&lt;/a&gt;中我们可以知道&lt;code&gt;pipe_fds_[0]&lt;/code&gt;是读管道，而&lt;code&gt;pipe_fds_[1]&lt;/code&gt;是写管道。这里有一丁点反直觉，就是pipe拿了两个fd，但是仍旧是单工的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://wizmann-pic.qiniudn.com/16-10-16/2335602.jpg"&gt;&lt;/p&gt;
&lt;p&gt;然后将读fd设为&lt;code&gt;O_NONBLOCK&lt;/code&gt;以供epoll调度，最后将&lt;code&gt;Func()&lt;/code&gt;函数传入&lt;code&gt;scheduler_&lt;/code&gt;中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里跑个题，想起了当年我大一的时候上过的通信导论的选修课。那会我还没有沉迷代码，还是一个积极乐观好好学习的新时代大学生。自从开始写了代码，人就越来越废物了，连女朋友都找不到了。     &lt;br&gt;
年轻人们啊，有饭辙干点啥都行，千万别写码啊。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Func()&lt;/code&gt;函数做的事情很简单，就是从管道里尝试poll一段数据，拿到数据后直接扔掉。因为管道里传来的数据并没有实际意义，这样设计的主要意义在于唤醒epoll。&lt;/p&gt;
&lt;p&gt;我们可以从&lt;code&gt;Notify()&lt;/code&gt;函数中看出 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Mon, 17 Oct 2016 01:28:40 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2016-10-17:/phxrpc-5.html</guid><category>phxrpc</category><category>ucontext</category><category>epoll</category></item><item><title>ucontext - phxrpc代码阅读(4)</title><link>http://wizmann.tk/phxrpc-4.html</link><description>&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;国庆假期过半，phxrpc的代码阅读大概要小小告一段落啦。因为这两天还要读工作相关的代码，以及最后几天还有一次短途旅行。&lt;/p&gt;
&lt;p&gt;所以非阻塞TCP流可能要留到下一篇了，这一篇只涉及非阻塞TCP流使用到的ucontext协程库，及其使用的一些框架代码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;161013更新：这点破东西写到今天才写完，GG。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;什么是ucontext&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;"Subroutines are special cases of ... coroutines." –Donald Knuth.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我们来看一下，什么是线程。线程是进程内一条执行流的状态，包含了硬件状态（硬件计数器，寄存器，条件码等）和堆栈中的数据。&lt;/p&gt;
&lt;p&gt;线程通常只有一个入口和一个出口。当线程返回时，线程的生命周期也结束了。所以，通常线程的执行由内核调度。&lt;/p&gt;
&lt;p&gt;协程的定义与线程类似，也是硬件状态+堆栈的状态组合。但是与线程不同的是，协程可以有多个出口。可以通过yield来暂停自己，调用其它协程。再次启动时，会从上次挂起的地方继续运行。&lt;/p&gt;
&lt;h2&gt;phxrpc中的ucontext&lt;/h2&gt;
&lt;p&gt;phxrpc提供了system和boost两种ucontext的实现，所以提供了一个&lt;code&gt;uthread_context_base&lt;/code&gt;的基类。其实在这里我是有一点怀疑虚函数的性能的，不过好在协程的切换以及网络IO操作还是比较耗性能的，所以虚函数多出来的几次内存寻址也并非不能接受 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Thu, 13 Oct 2016 23:45:24 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2016-10-13:/phxrpc-4.html</guid><category>phxrpc</category><category>ucontext</category><category>协程</category></item><item><title>打造你的专属键盘 — ErgoDone</title><link>http://wizmann.tk/ergodone.html</link><description>&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;低能预警：这是最没有技术含量的一篇博客，无关人员可以撤离。&lt;/p&gt;
&lt;p&gt;部分图片来自网络，侵删&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个十一假期，亲手DIY了一把键盘。当然，我只搞定了焊接部分，把不同的组件拼在了一起。&lt;/p&gt;
&lt;p&gt;在焊接的过程中，也学习到了一些新知识。写在这里，记录下来。&lt;/p&gt;
&lt;h2&gt;ErgoDone介绍&lt;/h2&gt;
&lt;p&gt;ErgoDone是著名开源硬件ErgoDox的中国特色版本，精简了一些硬件以控制成本。总体价格在500RMB左右，是工薪阶级装逼界的一颗新星。&lt;/p&gt;
&lt;p&gt;Ergodox的一个版本：
&lt;img alt="" src="http://wizmann-pic.qiniudn.com/16-10-2/41980975.jpg"&gt;&lt;/p&gt;
&lt;p&gt;ErgoDone明显就屌丝了许多：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://wizmann-pic.qiniudn.com/16-10-5/28663395.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;键盘主控&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="http://wizmann-pic.qiniudn.com/16-10-2/32662639.jpg"&gt;&lt;/p&gt;
&lt;p&gt;ErgoDone使用了Arduino pro micro做为主控，基中使用了mega32u4做为芯片，提供了模拟USB输入设备的相关函数（包括键盘、鼠标）。网上有许多现成的范例，用这款芯片（以及另一版使用mega32u4的Arduino开发版，Arduino Leonardo）制作体感鼠标（搭配陀螺仪）、游戏摇杆（搭配相关硬件）以及各种专用输入设备。&lt;/p&gt;
&lt;p&gt;Arduino pro micro淘宝价不到20块钱，相对来说算是非常超值了。&lt;/p&gt;
&lt;h2&gt;焊接&lt;/h2&gt;
&lt;p&gt;由于本人算是菜的抠脚的业余选手，在这个键盘上的主要工作就是焊接。然而，就在焊接这样一件相对简单的工作上，我也是踩了不少坑 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Wed, 05 Oct 2016 21:38:58 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2016-10-05:/ergodone.html</guid><category>ot</category><category>ergodone</category><category>keyboard</category></item><item><title>阻塞TCP流 - phxrpc代码阅读(3)</title><link>http://wizmann.tk/phxrpc-3.html</link><description>&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;phxrpc的流（&lt;code&gt;stream&lt;/code&gt;和&lt;code&gt;streambuf&lt;/code&gt;）与网络访问其实是耦合在一起的，所以本文可以结合着第一篇笔记一起来看。虽然我非常想吐槽这种强耦合性的设计，但是我决定还是好好理解phxrpc的设计之后。。。攒一波大的：）&lt;/p&gt;
&lt;h2&gt;BlockTcpStreamBuf&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;class BlockTcpStreamBuf&lt;/code&gt;继承自&lt;code&gt;BaseTcpStreamBuf&lt;/code&gt;。其中重写了&lt;code&gt;precv&lt;/code&gt;和&lt;code&gt;psend&lt;/code&gt;两个函数，并且持有了一个文件描述符(file descriptor)：&lt;code&gt;socket_&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;precv&lt;/code&gt;和&lt;code&gt;psend&lt;/code&gt;直接调用了&lt;code&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/code&gt;中的&lt;code&gt;recv(2)&lt;/code&gt;和&lt;code&gt;send(2)&lt;/code&gt;，并没有其它操作。&lt;/p&gt;
&lt;p&gt;网络相关的操作，则由&lt;code&gt;class BlockTcpStream&lt;/code&gt;来负责。&lt;code&gt;BlockTcpStreamBuf&lt;/code&gt;只负责IO部分。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BaseTcpUtils&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;SetNonBlock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;false …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Mon, 03 Oct 2016 22:22:14 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2016-10-03:/phxrpc-3.html</guid><category>phxrpc</category><category>tcpip</category><category>poll</category><category>socket</category></item><item><title>定时器以及其它 - phxrpc阅读笔记(2)</title><link>http://wizmann.tk/phxrpc-2.html</link><description>&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;phxrpc使用了协程(ucontext)和IO复用技术(epoll)来实现网络通信。定时器在其中起到了非常重要的作用。下面我们就来分析一下phxrpc的&lt;code&gt;timer.[h|cpp]&lt;/code&gt;中的代码。&lt;/p&gt;
&lt;h2&gt;system_clock vs steady_clock&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;system_clock&lt;/code&gt;和&lt;code&gt;steadly_clock&lt;/code&gt;都是来自&lt;code&gt;&amp;lt;chrono&amp;gt;&lt;/code&gt;库，都是用来获取当前时间的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;system_clock&lt;/code&gt;用来从系统时钟获取时钟时间(wall clock time)，而&lt;code&gt;steadly_clock&lt;/code&gt;获取的是时钟tick，而且保证随着时间的推移，时钟tick数不会变小。&lt;/p&gt;
&lt;p&gt;然而实际上，在某些系统下，这两个时钟的实现是一致的。详细信息可以参考&lt;a href="http://stackoverflow.com/questions/13263277/difference-between-stdsystem-clock-and-stdsteady-clock"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：在clang++ 4.2.1, g++ 5.4 下实验，这两个时钟是不同的。所以个人认为在这里最好不要做任何无意义的假设。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;几毫秒的安睡&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Thu, 29 Sep 2016 01:28:09 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2016-09-29:/phxrpc-2.html</guid><category>RPC</category><category>STL</category><category>priority_queue</category><category>C++</category><category>phxrpc</category></item><item><title>自定义你的stream buffer - phxrpc阅读笔记(1)</title><link>http://wizmann.tk/phxrpc-1.html</link><description>&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/tencent-wechat/phxrpc"&gt;phxrpc&lt;/a&gt;是微信团队开源的一个轻量级RPC框架。&lt;/p&gt;
&lt;p&gt;我对RPC这些东西了解不多，看到phxrpc的代码相对简单，而且还在初步开发阶段（在本文写作时，版本号是0.8）。所以想读一读，提高一下姿势水平。&lt;/p&gt;
&lt;p&gt;就是这样。&lt;/p&gt;
&lt;h2&gt;自定义stream buffer&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;network/socket_stream_base.[h|cpp]&lt;/code&gt;中的&lt;code&gt;class BaseTcpStreamBuf&lt;/code&gt;继承了&lt;code&gt;std::streambuf&lt;/code&gt;，自定义了一个流缓冲区，用于接收/发送TCP数据包。&lt;/p&gt;
&lt;p&gt;这个用法比较新颖（或者是我见识少），网上的资料也不多。这里翻译一篇&lt;a href="http://www.mr-edd.co.uk/blog/beginners_guide_streambuf"&gt;介绍文章&lt;/a&gt;，学习一下新姿势。&lt;/p&gt;
&lt;h2&gt;A beginner's guide to writing a custom stream buffer&lt;/h2&gt;
&lt;p&gt;流(streams)是STL中提供的一个重要的抽象概念。著名的“Hello world”程序，便是使用了std …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Wed, 28 Sep 2016 22:35:55 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2016-09-28:/phxrpc-1.html</guid><category>System Design</category><category>RPC</category><category>streambuf</category><category>C++</category><category>phxrpc</category></item><item><title>Code Golf - Heapify</title><link>http://wizmann.tk/code-golf-heapify.html</link><description>&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;heapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;nth_element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can implement a "heapify" by only four lines of code. And the time complexity is &lt;code&gt;O(n)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Fancy …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sat, 01 Aug 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2015-08-01:/code-golf-heapify.html</guid><category>code golf</category></item><item><title>Using Set Cover to Optimize a Large-Scale Low Latency Distributed Graph</title><link>http://wizmann.tk/using-set-cover-algorithm-to-optimize-a-large-scale-low-latency-distributed-graph.html</link><description>&lt;h2&gt;Background&lt;/h2&gt;
&lt;p&gt;Linkedin (or other social networks, such as Facebook and G+) use the "social graph information" to show the social relationship between you and other members.&lt;/p&gt;
&lt;p&gt;Such as, "You and Mr.Obama share 10 mutual friends" or "You have 1,000 second-degree connections".&lt;/p&gt;
&lt;p&gt;This feature is very common for a …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sun, 26 Jul 2015 22:48:33 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2015-07-26:/using-set-cover-algorithm-to-optimize-a-large-scale-low-latency-distributed-graph.html</guid><category>System Design</category><category>Linkedin</category><category>Social Network</category></item><item><title>Workflowy full notes</title><link>http://wizmann.tk/workflowy-full-notes.html</link><description>&lt;p&gt;Recently, I'm becoming a crazy fan of &lt;a href="workflwoy.com"&gt;workflowy&lt;/a&gt; because its ability to build a personal wiki concisely.&lt;/p&gt;
&lt;p&gt;However, there's only one thing bothers me that workflowy hide all the notes as the screenshot below, and it annoys me a lot.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Alt text" src="data:image/png;base64,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"&gt;&lt;/p&gt;
&lt;p&gt;Luckily we can always find a way to get around …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Fri, 22 May 2015 09:51:47 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2015-05-22:/workflowy-full-notes.html</guid><category>css</category><category>stylish</category><category>front-end development</category></item><item><title>用C++实现一个通用的sort函数</title><link>http://wizmann.tk/a-common-sorting-function-with-cpp.html</link><description>&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;用C++实现一个尽可能通用的sort函数&lt;/p&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;一个通用的sort函数应该包含以下要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确实可以排序(LOL)&lt;/li&gt;
&lt;li&gt;可以应对C-style array和C++-style container的排序需求&lt;/li&gt;
&lt;li&gt;可以应用于任意random access container&lt;/li&gt;
&lt;li&gt;可以使用用户自定义的排序函数 / 仿函数 / lambda函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;实现&lt;/h2&gt;
&lt;p&gt;为了与std中的通用函数做区别，这里的命名规则，包括类型与函数，都在前面加了"my"以示区别。可能与标准的命名法有出入，所以仅做示例用。&lt;/p&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; 拷贝代码是愚蠢的行为。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;或者说，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 对于同一钟实现，尽量使用同一份代码。 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;感谢C++ Templates，对于不同类型与需求的函数，我们可以将生成多份代码的劳动放心的交给编译器。并且，Templates的代码生成是在编译期完成的，即不会造成额外的代码膨胀（如果你姿势正确的话），也一般不会造成额外的运行时开销。&lt;/p&gt;
&lt;h3&gt;函数原型&lt;/h3&gt;
&lt;p&gt;我们模仿std::sort来进行开发。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template&amp;lt; class It, class Compare &amp;gt;
void sort …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sat, 25 Apr 2015 11:17:01 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2015-04-25:/a-common-sorting-function-with-cpp.html</guid><category>C++</category><category>sort</category></item><item><title>Beauty-of-Programming 2015 Qualification Round Tutorial</title><link>http://wizmann.tk/beauty-of-programming-2015-qualification-round.html</link><description>&lt;h2&gt;A. 2月29日 (Feb. 29th)&lt;/h2&gt;
&lt;h3&gt;Description&lt;/h3&gt;
&lt;p&gt;Given a starting date and an ending date. Count how many Feb. 29th are between the given dates.&lt;/p&gt;
&lt;h3&gt;Solution&lt;/h3&gt;
&lt;p&gt;The easiest way, of course, the brute force, which is quite simple with Python using the &lt;code&gt;datetime&lt;/code&gt; lib.&lt;/p&gt;
&lt;p&gt;However, it's not an effective way for the …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sat, 25 Apr 2015 00:54:08 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2015-04-25:/beauty-of-programming-2015-qualification-round.html</guid><category>algorithm</category><category>算法</category><category>题解</category><category>Microsoft</category></item><item><title>GCJ Qualification Round 2015 题解</title><link>http://wizmann.tk/gcj-qualification-round-2015-tutorial.html</link><description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;这篇日志用中文写是因为想省点时间打游戏。。。（请鄙视我吧。。。&lt;/p&gt;
&lt;h2&gt;A. Standing Ovation&lt;/h2&gt;
&lt;h3&gt;题意&lt;/h3&gt;
&lt;p&gt;这是一个骗掌声的故事。&lt;/p&gt;
&lt;p&gt;当演出结束后，观众们要站起来鼓掌。但是有些观众比较羞涩，只有在k个人站起来鼓掌后才会故障。&lt;/p&gt;
&lt;p&gt;你的目标是在观众中安插一些卧底领掌，让所有观众都站起来鼓掌。（臭不要脸）&lt;/p&gt;
&lt;p&gt;求最少的卧底数。&lt;/p&gt;
&lt;h3&gt;数据规模&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;抛开数据规模谈解题，都是TM耍流氓。 —— Wizmann&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;100组数据。&lt;/p&gt;
&lt;p&gt;小数据集，观众羞涩值的范围：0 ≤ Smax ≤ 6.&lt;/p&gt;
&lt;p&gt;大数据集，观众羞涩值的范围：0 ≤ Smax ≤ 1000.&lt;/p&gt;
&lt;h3&gt;解题&lt;/h3&gt;
&lt;p&gt;本题比较简单。有两种方法，一是暴力枚举，因为大数据集中，观众羞涩值最大只为1000,即最大安插卧底数不超过1000。(当然，二分也可以，不过对于1000的数据集，真心没啥必要。)&lt;/p&gt;
&lt;p&gt;二是O(N)的一个遍历，在观众羞涩的不想鼓掌时，安插相应数量的卧底。&lt;/p&gt;
&lt;p&gt;本题推荐方法一。因为个人感觉，在编程竞赛中 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sun, 12 Apr 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2015-04-12:/gcj-qualification-round-2015-tutorial.html</guid><category>GCJ</category><category>algorithm</category><category>算法</category><category>题解</category><category>google</category></item><item><title>ZeroMQ启示录</title><link>http://wizmann.tk/inspiration-from-zeromq.html</link><description>&lt;h2&gt;ØMQ是一个消息系统&lt;/h2&gt;
&lt;p&gt;ZeroMQ是一个消息系统，也被称为“消息中间件”。它被广泛的用于经济、游戏、嵌入式等领域。&lt;/p&gt;
&lt;h3&gt;什么是消息系统&lt;/h3&gt;
&lt;p&gt;打个比方，消息系统就像我们使用的IM软件一样。首先，一方决定将消息发往何处（一对一或一对多）。然后将信息打包，点击发送按钮。之后，IM系统会帮你料理剩余的事务。&lt;/p&gt;
&lt;p&gt;但是，它们也有很大的不同点。IM系统对于消息系统似乎太低效了一点。另外，消息系统是没有用户界面（GUI）的。在错误发生时，消息的另一端也不会有人来智能的介入处理。&lt;/p&gt;
&lt;p&gt;所以，我们可以这样下定义。消息系统是具有高效性和容错性的消息传递解决方案。&lt;/p&gt;
&lt;h3&gt;ZeroMQ的起源和发展&lt;/h3&gt;
&lt;p&gt;ZeroMQ最先的设想是实现一个炒鸡快的用于证券交易的消息系统，所以在设计初期的关注点就是在极致的优化上。&lt;/p&gt;
&lt;p&gt;第一年的工作重点，在于发明性能测试的方法，和设计高效架构。&lt;/p&gt;
&lt;p&gt;之后，大约在第二年，工作重点转移到实现一个通用的消息系统，以应用于分布式系统，使其可以利用&lt;strong&gt;不同的编程语言&lt;/strong&gt;，使用&lt;strong&gt;不同方式&lt;/strong&gt;，来传递&lt;strong&gt;各种模式&lt;/strong&gt;的信息。&lt;/p&gt;
&lt;h2&gt;启示1：独立应用 vs. 程序库 …&lt;/h2&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Tue, 07 Apr 2015 10:01:34 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2015-04-07:/inspiration-from-zeromq.html</guid><category>zeromq</category><category>distributed system</category><category>system-design</category></item><item><title>Codeforces Round #290 (Div. 2) Tutorial</title><link>http://wizmann.tk/cf-290-div-2.html</link><description>&lt;h2&gt;A. Fox And Snake&lt;/h2&gt;
&lt;p&gt;Implementation&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;

&lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;#&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;.&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;#&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;.&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;B. Fox And Two Dots&lt;/h2&gt;
&lt;p&gt;DFS …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Wed, 18 Feb 2015 00:30:24 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2015-02-18:/cf-290-div-2.html</guid><category>codeforces</category><category>algorithm</category></item><item><title>Codeforces Round #289 (Div. 2) Tutorial</title><link>http://wizmann.tk/cf-289-div-2.html</link><description>&lt;h2&gt;A. Maximum in Table&lt;/h2&gt;
&lt;p&gt;Simulation. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;B …&lt;/h2&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Mon, 16 Feb 2015 21:16:31 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2015-02-16:/cf-289-div-2.html</guid><category>codeforces</category><category>algorithm</category><category>算法</category><category>题解</category></item><item><title>Codeforces Round #288 (Div. 2)</title><link>http://wizmann.tk/cf-288-div-2.html</link><description>&lt;h2&gt;A. Pasha and Pixels&lt;/h2&gt;
&lt;p&gt;Brute force.&lt;/p&gt;
&lt;p&gt;There are multiple ways to form a 2*2 square at one single step.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Alt text" src="http://wizmann-pic.qiniudn.com/6fb53c51539b47559cf0d122a832cf63"&gt;&lt;/p&gt;
&lt;p&gt;So at every step, we have to check the neighbours of pixel that is colored black.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cp"&gt;#define …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Mon, 16 Feb 2015 21:16:30 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2015-02-16:/cf-288-div-2.html</guid><category>codeforces</category><category>algorithm</category><category>算法</category><category>题解</category></item><item><title>Sequence Median</title><link>http://wizmann.tk/sequence-median.html</link><description>&lt;h2&gt;Description&lt;/h2&gt;
&lt;p&gt;Given a sequence of integer numbers, try to find the median of the sequence.&lt;/p&gt;
&lt;h3&gt;Extending&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Make sure your code can get the right answer in any conditions&lt;/li&gt;
&lt;li&gt;Make sure your code work effectively on some special kinds of sequence. For example, ordered sequence or a nearly ordered one, a …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sun, 14 Dec 2014 16:51:50 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-12-14:/sequence-median.html</guid><category>quick sort</category><category>median</category><category>partition</category><category>priority queue</category></item><item><title>类型-长度-值（TLV）协议</title><link>http://wizmann.tk/tlv-protocol.html</link><description>&lt;p&gt;在数据通信协议中，可选的信息或字段通常使用type-length-value（a.k.a TLV）元素来进行编码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Type - 类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用来标示字段类型的值，通常是一个二进制值或简单的字母&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Length - 长度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;字段长度，单位通常为Byte&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Value - 值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个变长的比特数组用来存储这个字段的值&lt;/p&gt;
&lt;h2&gt;优势&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TLV序列方便遍历查找&lt;/li&gt;
&lt;li&gt;新的字段可以无痛的加入现有的协议中。解析的时候，对于未知的字段，可以轻松的跳过。这点与XML类似&lt;/li&gt;
&lt;li&gt;TLV元素的顺序可以是随意的&lt;/li&gt;
&lt;li&gt;TLV元素通常使用二进制存储，可以使解析速度加快并且使数据更小&lt;/li&gt;
&lt;li&gt;TLV可以与XML数据相互转换，易于人类阅读&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;例子&lt;/h2&gt;
&lt;p&gt;在这里，我们以protobuf的可选和变长字段为例。&lt;/p&gt;
&lt;h3&gt;field_number ++ wire_type&lt;/h3&gt;
&lt;p&gt;每一个protobuf的字段在传输时，都会加上&lt;code&gt;field_number&lt;/code&gt;和&lt;code&gt;wire_type&lt;/code&gt;这两个值，这两个值组成这个字段的key。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;key = (field_number &amp;lt;&amp;lt; 3) | wire_type
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;field_number&lt;/code&gt;标明了字段的编号，方便协议向前向后的兼容。而 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Mon, 17 Nov 2014 00:25:42 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-11-17:/tlv-protocol.html</guid><category>TLV</category><category>protocol</category><category>network</category><category>protobuf</category><category>flatbuffer</category></item><item><title>Reasons They Recruit</title><link>http://wizmann.tk/reasons-they-recruit.html</link><description>&lt;blockquote&gt;
&lt;p&gt;From &lt;em&gt;Ace of Programming Interview&lt;/em&gt;, Cpt1 - Hiring Programmers: The Inside Story&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Establish a Rapport&lt;/h2&gt;
&lt;p&gt;For an interviewee, one the the most efficient way to build a rapport is to &lt;strong&gt;try to see things in from the interviewer's perspective&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;understand the motivation of the interviewer&lt;/li&gt;
&lt;li&gt;establishing a common ground&lt;/li&gt;
&lt;li&gt;adapting your …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sun, 16 Nov 2014 01:03:14 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-11-16:/reasons-they-recruit.html</guid><category>interview</category><category>programming interview</category><category>读书</category></item><item><title>Quora - What are effective ways to assess if someone is good at "getting things done"?</title><link>http://wizmann.tk/good-at-get-things-done.html</link><description>&lt;blockquote&gt;
&lt;p&gt;Ian McAllister, GM at Amazon. I lead the AmazonSmile program.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;First, let’s break “getting things done” into two components: “excellent functional skills” and “drive”. Someone with great functional skills but poor drive will not get (enough) things done. Someone with great drive but poor functional skills will not get …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sat, 15 Nov 2014 16:08:10 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-11-15:/good-at-get-things-done.html</guid><category>get things done</category><category>quora</category><category>career</category></item><item><title>The Checklist of Steve Yegge</title><link>http://wizmann.tk/steve-yegge-interview-checklist.html</link><description>&lt;blockquote&gt;
&lt;p&gt;Hey man, I don't know that stuff&lt;/p&gt;
&lt;p&gt;Stevey's talking aboooooout&lt;/p&gt;
&lt;p&gt;If my boss thinks it's important&lt;/p&gt;
&lt;p&gt;I'm gonna get fiiiiiiiiiired&lt;/p&gt;
&lt;p&gt;Oooh yeah baaaby baaaay-beeeeee....&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;非技术部分&lt;/h2&gt;
&lt;h3&gt;热身&lt;/h3&gt;
&lt;h4&gt;好好读一本讲数据结构和算法的书&lt;/h4&gt;
&lt;p&gt;熟悉一些“术语”，可以强化分辨问题的能力。&lt;/p&gt;
&lt;p&gt;Yegge推荐了 Steven S. Skiena 的&lt;a href="http://book.douban.com/subject/4048566/"&gt;《算法设计手册》&lt;/a&gt;，而我推荐的是
Udi Manber 的&lt;a href="http://book.douban.com/subject/1436134/"&gt;《算法引论》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;每一本书都有它的长处短处。找一本评价不错的书，认真读完，肯定会有收获。&lt;/p&gt;
&lt;h4&gt;找个朋友来面试你，尝试白板编程&lt;/h4&gt;
&lt;p&gt;在白纸/白板上编程的体验和在计算机上大有不同。没有条件的情况下 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sun, 26 Oct 2014 00:24:44 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-10-26:/steve-yegge-interview-checklist.html</guid><category>interview</category><category>Google</category></item><item><title>Snake Problem</title><link>http://wizmann.tk/snake-problem.html</link><description>&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;在一个平面上，有n+m条蛇，其中n条蛇沿水平方向（y轴方向）移动，m条蛇沿竖直方向（x轴方向）移动。&lt;/p&gt;
&lt;p&gt;现给出这些蛇头和尾所在的坐标点，求出这n+m条蛇在此时共有多少个交点。在同一个方向移动的蛇不会有交点。&lt;/p&gt;
&lt;p&gt;如图所示，n = 5, m = 4，这些蛇一共有5个交点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Alt text" src="data:image/png;base64,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"&gt;&lt;/p&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;对于此题，最简单直接的方法就是枚举蛇两两之间的关系，这种算法的时间复杂度为O(n^2)。&lt;/p&gt;
&lt;p&gt;当然，我们不能满足于这种暴力的解法。那么，有没有更优美的方法呢？&lt;/p&gt;
&lt;p&gt;&lt;img alt="Alt text" src="data:image/png;base64,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"&gt;&lt;/p&gt;
&lt;p&gt;对于这一条在y轴方向上的（红）蛇来说，它与x轴方向上的（黑）蛇共有三个交点。那么，也就意味着，问题的关键在于，我们如何快速确定某一条红蛇（或黑蛇）与其它蛇一共有多少个交点。&lt;/p&gt;
&lt;p&gt;我们可以做出如下假设，我们知道当x = k时，所有在平面上的蛇的位置。根据这个假设，我们可以使用区间求和的算法来确定竖直位置上的蛇会有多少个焦点。&lt;/p&gt;
&lt;p&gt;假设我们从x = 0到x …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Mon, 20 Oct 2014 09:11:27 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-10-20:/snake-problem.html</guid><category>binary indexed tree</category><category>algorithm</category><category>geometric</category></item><item><title>思维训练 - Thinkin' in induction 2</title><link>http://wizmann.tk/thinking-in-induction-2.html</link><description>&lt;h2&gt;最大导出子图（maximal induced graph）&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;你现在在组织一个学术会议。现在你有一份人员名单。假定名单中的每一个人都同意到达，并且有充足的时间交流意见。同时，每一个科学家都写下了他愿意与其进行交流的科学家的名字。&lt;/p&gt;
&lt;p&gt;现在，问题来了：&lt;del&gt;挖掘机技术哪家强？&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;如果要保证每一位科学家至少能与k位到场的科学家进行深入的交♂流♂。那么我们最多可以邀请多少人到会？&lt;/p&gt;
&lt;p&gt;注：如果A愿意和B交流，AB一定会进行交流。反之亦然。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以把问题转化成数学语言：对于一个无向图&lt;code&gt;G=(V, E)&lt;/code&gt;，试求得G的最大导出子图H，使得H中所有顶点的度大于或等于k，或者证明这样的子图是不存在的。&lt;/p&gt;
&lt;p&gt;我们继续使用归纳的思想来解决这个问题。&lt;/p&gt;
&lt;p&gt;易得，对于顶点数为k的图，如果存在k-导出子图，则该图必为一个完全图。&lt;/p&gt;
&lt;p&gt;假设，对于任意顶点数小于n的图，我们总可以找到图的k-最大导出子图。&lt;/p&gt;
&lt;p&gt;对于有n个顶点的图G来说，如果有任意顶点的度小于k，那么对于图G的任意子图，此顶点的度总小于k。&lt;/p&gt;
&lt;p&gt;所以，对于图中任意度小于k的点，必然不属于所求的子图。于是，我们每次删除一个不属于k-导出子图的点，就可以把有n个顶点的图问题化归为n-1顶点的图问题。&lt;/p&gt;
&lt;h2&gt;一对一映射&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个集合A和一个映射关系f。求A的一个子集S，使得f对于S是一个一对一映射 …&lt;/p&gt;&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Wed, 01 Oct 2014 00:05:29 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-10-01:/thinking-in-induction-2.html</guid><category>induction</category><category>algorithm</category></item><item><title>思维训练 - Thinkin' in induction</title><link>http://wizmann.tk/thinking-in-induction.html</link><description>&lt;h2&gt;热身题 - 24Game&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://codeforces.com/contest/469/problem/C"&gt;原题请戳我&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;题意&lt;/h3&gt;
&lt;p&gt;给你一个包含整数1...n的集合S。接下来进行n-1次操作，每次操作从集合S中选取两个数，在加、减、乘三种运算中选取一种，将结果放回再集合S。在n-1次操作完成后，集合S中只剩下一个数。求问一种取数和运算策略，使最后的结果为24。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;S = [1, 2, 3, 4, 5]&lt;/p&gt;
&lt;p&gt;我们选取(2, 5)，并进行加法运算，获得结果7。再将7放回集合S中。&lt;/p&gt;
&lt;p&gt;此时，S = [1, 3, 4, 7]。&lt;/p&gt;
&lt;h3&gt;数据范围&lt;/h3&gt;
&lt;p&gt;1 &amp;lt;= n &amp;lt;= 100000&lt;/p&gt;
&lt;h3&gt;解答&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;建议：请思考10分钟后再来看答案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们日常写代码，往往是为了实现一个功能或者实现一套逻辑。这时候，我们做的事一般是从零开始，然后逐步迭代，最终实现目标。&lt;/p&gt;
&lt;p&gt;这是正常的一种思维方式，也是不错的思维 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Fri, 26 Sep 2014 00:10:45 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-09-26:/thinking-in-induction.html</guid><category>induction</category><category>binary tree</category><category>codeforces</category></item><item><title>FlatBuffer代码阅读 - 1</title><link>http://wizmann.tk/read-flatbuffer-1.html</link><description>&lt;h2&gt;FlatBuffer白皮书&lt;/h2&gt;
&lt;p&gt;Flatbuffer是一个全新的序列化库。&lt;/p&gt;
&lt;h3&gt;动机&lt;/h3&gt;
&lt;p&gt;在远古时代，程序性能基本取决于你的指令和循环运行的有多快。但是，在如今的计算机上，计算组件的速度已经远远超过存储组件的速度。如果你想让你的程序飞起来，最重要的就是优化你的内存使用。例如，用多少内存，怎样布局内存，如何分配内存，何时拷贝内存等。&lt;/p&gt;
&lt;p&gt;序列化是在程序中非常常见的一种操作，并且通常是程序性能低下的主要原因。一是由于序列化需要额外的临时空间去解析和表示数据，二是由于不优雅的内存分配模式和局部性。&lt;/p&gt;
&lt;p&gt;如果一个序列化框架可以不使用额外的对象，没有额外的内存分配，没有内存拷贝，良好的数据局部性，这正是太好不过。不过当下的很多框架通常不能满足以上的条件，因为它们需要向前/向后兼容，需要兼容不同的平台，例如大端/小端和内存对齐都是需要进行兼容性处理的。&lt;/p&gt;
&lt;p&gt;FlatBuffer可以做到以上的一切。&lt;/p&gt;
&lt;p&gt;Flatbuffer尤其适合移动设备（内存容量和带宽比桌面设备的要低不少），以及需要高性能的应用：游戏。&lt;/p&gt;
&lt;h3&gt;FlatBuffers&lt;/h3&gt;
&lt;h4&gt;总述&lt;/h4&gt;
&lt;p&gt;Flatbuffer是一个二进制的buffer。Flatbuffer可以包含嵌套对象如struct、table、vector等并使用偏移量来进行寻址，这样一来，我们就可以像遍历基于指针的结构一样，对flatbuffer元素进行in-place的遍历。
Flatbuffer使用严格的字节对齐和字节顺序（通常是小端）以保证可以跨平台使用。&lt;/p&gt;
&lt;p&gt;另外，像table这样的对象，Flatbuffer提供了向前 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sun, 21 Sep 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-09-21:/read-flatbuffer-1.html</guid><category>flatbuffer</category></item><item><title>最小表示法及其证明</title><link>http://wizmann.tk/minimal-round-string.html</link><description>&lt;h2&gt;问题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;对于一个字符串S，求S的循环的同构字符串S’中字典序最小的一个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们举例说明，字符串"abcd"的循环同构字符串有：&lt;code&gt;["abcd", "bcda", "cdab", "dabc"]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;题目的目标是求这些字符串中字典序最小的那个。&lt;/p&gt;
&lt;h2&gt;暴力解法&lt;/h2&gt;
&lt;p&gt;暴力解法非常直观，直接枚举字符串的起点，然后找到构成最小字符串的那一个。&lt;/p&gt;
&lt;p&gt;代码就不在这里写了。&lt;/p&gt;
&lt;h2&gt;最小表示法&lt;/h2&gt;
&lt;p&gt;最小表示法是解决同构字符串最小表示的巧妙算法。&lt;/p&gt;
&lt;p&gt;其算法描述如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;令i=0,j=1
如果S[i] &amp;gt; S[j] i=j, j=i+1
如果S[i] &amp;lt; S[j] j++
如果S[i] == S[j] 设指针k，分别从i和j位置向下比较，直到S[i] != S[j]
         如果S …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Wed, 17 Sep 2014 00:46:16 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-09-17:/minimal-round-string.html</guid><category>string</category><category>字符串</category><category>最小表示法</category><category>algorithm</category></item><item><title>System Design - 最热门的IP地址</title><link>http://wizmann.tk/hottest-ip-address.html</link><description>&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;问题是非常流行的，也确实流行了一阵的system-design问题。在&lt;a href="http://www.zhihu.com/question/19805967"&gt;知乎&lt;/a&gt;上再次被人提起。然后我非常欣赏&lt;a href="http://zhi.hu/3gJb"&gt;陈硕的回答&lt;/a&gt;。所以要写一篇文章，记下自己的感想。&lt;/p&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;海量数据算法:如何从超过10G的记录IP地址的日志中，较快的找出登录次数最多的一个IP？&lt;/p&gt;
&lt;h2&gt;银弹？&lt;/h2&gt;
&lt;p&gt;面对这种system-design问题，尤其是这种，&lt;strong&gt;非高并发、非实时&lt;/strong&gt;的问题，很多人会采用_map-reduce_ —— 解决system-design问题的银弹。&lt;/p&gt;
&lt;p&gt;我对map-reduce的理解非常肤浅，但是可以解释一下大概的流程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将日志进行分片。把hash(ip)相同的ip地址分到同一个片中。（注：这里的hash并不是签名函数，只是一个分片标示）&lt;/li&gt;
&lt;li&gt;分片后的日志的大小会小很多，可以方便的进行排序，记数。&lt;/li&gt;
&lt;li&gt;然后再从各个片中，统计出最热门的IP地址。（或TopK的IP地址）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果不满意我的答案的话，推荐&lt;a href="http://book.douban.com/subject/19934150/"&gt;Mining of Massive Datasets&lt;/a&gt;一书，其中对map-reduce算法做一番不错的介绍。&lt;/p&gt;
&lt;h2&gt;正确的分析姿势&lt;/h2&gt;
&lt;h3&gt;业务实体&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;业务实体拥有四种主要的组件： 信息模型、生命周期模型 …&lt;/p&gt;&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Fri, 08 Aug 2014 01:25:54 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-08-08:/hottest-ip-address.html</guid><category>interview</category><category>system-design</category></item><item><title>Single Number Problem</title><link>http://wizmann.tk/single-number-in-the-array.html</link><description>&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;There are a lot of interview problem based on the 1D-array, which is the one of the easiest "data structure".&lt;/p&gt;
&lt;p&gt;But the problem about that simple data structure might not be that simple. Here is the summary of the problem about 1D-array.&lt;/p&gt;
&lt;p&gt;Of course, most of them come from …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Tue, 05 Aug 2014 23:07:02 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-08-05:/single-number-in-the-array.html</guid><category>算法</category><category>leetcode</category><category>algorithm</category></item><item><title>简明Python魔法 - 2</title><link>http://wizmann.tk/python-magic-2.html</link><description>&lt;h2&gt;再说描述符 - Descriptor&lt;/h2&gt;
&lt;h3&gt;最简单的描述符&lt;/h3&gt;
&lt;p&gt;覆写类的&lt;code&gt;__get__&lt;/code&gt;和&lt;code&gt;__setter__&lt;/code&gt;函数就可以实现一个简单的描述符。对某个类型实例的读写进行额外的控制。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;datetime&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CurrentDate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__get__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;owner&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;today&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__set__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;        &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;NotImplementedError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Can&amp;#39;t change the current date.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;...&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Example&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;    &lt;span class="n"&gt;date&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CurrentDate&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="gp"&gt;...&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Example&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;
&lt;span class="go"&gt;datetime.date(2008, 11, 24 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sun, 27 Jul 2014 14:23:10 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-07-27:/python-magic-2.html</guid><category>python</category></item><item><title>简明Python魔法 - 1</title><link>http://wizmann.tk/python-magic-1.html</link><description>&lt;h2&gt;Python中类的实现&lt;/h2&gt;
&lt;p&gt;在Python的Web框架Django中，Python类的构造特性实现了它大部分的核心功能。&lt;/p&gt;
&lt;p&gt;当Python解释器遇到类声明时，会创建一个新的namespace ，并执行其内的所有代码，并将变量注册到这个namespace中。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Loading...&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;    &lt;span class="n"&gt;spam&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;eggs&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Done!&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;
&lt;span class="go"&gt;Loading...&lt;/span&gt;
&lt;span class="go"&gt;Done!&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;spam&lt;/span&gt;
&lt;span class="go"&gt;&amp;#39;eggs&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;动态的实现一个类&lt;/h3&gt;
&lt;p&gt;使用type方法可以动态的代码中实现一个类，接受三个参数“类名”、“基类”、“属性”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Bar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Bar&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;,),&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;spam&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;eggs&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Bar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;spam&lt;/span&gt;
&lt;span class="go"&gt;&amp;#39;eggs&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;超类改变一切&lt;/h3&gt;
&lt;p&gt;“metaprogramming”是指一种在程序运行时创建或改变代码的编程手段。&lt;code&gt;type&lt;/code&gt;是一个metaclass，一个创建其它类的metaclass。&lt;/p&gt;
&lt;p&gt;我们可以替换掉原生的&lt;code&gt;type&lt;/code&gt;，使用我们自己的版本，从而控制创建类的过程。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;class …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sat, 26 Jul 2014 22:23:34 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-07-26:/python-magic-1.html</guid><category>python</category></item><item><title>Codeforces 447D DZY Loves Modification</title><link>http://wizmann.tk/cf-447d.html</link><description>&lt;h2&gt;题意&lt;/h2&gt;
&lt;p&gt;给你一个n * m的矩阵，让你做K次操作，使得最后得到的值最大。&lt;/p&gt;
&lt;p&gt;操作有两种：&lt;/p&gt;
&lt;p&gt;一是&lt;strong&gt;在任意一行上&lt;/strong&gt;操作，最终的结果值加上这一行数的和，然后这一行每一个数都要减去p。&lt;/p&gt;
&lt;p&gt;二是&lt;strong&gt;在任意一列上&lt;/strong&gt;操作，最终的结果值加上这一列数的和，然后这一列每一个数都要减去p。&lt;/p&gt;
&lt;p&gt;数据范围：1 ≤ n, m ≤ 10^3; 1 ≤ k ≤ 10^6; 1 ≤ p ≤ 100&lt;/p&gt;
&lt;h2&gt;退化版的题目思路&lt;/h2&gt;
&lt;p&gt;如果我们只限定一种操作，此题就是简单题了。我们维护一个大根堆，堆中保存每一行（或列）之和。&lt;/p&gt;
&lt;p&gt;每次操作只需要取出最大值，加到最终结果上。之后将这个值减去对应的p * n（或p * m），再加入堆中。&lt;/p&gt;
&lt;p&gt;经过K次循环，就可以得到最后的答案了。&lt;/p&gt;
&lt;h2&gt;真正的题目思路&lt;/h2&gt;
&lt;p&gt;对于行和列同时操作，我们也可以套用这种方法。但是要解决对行操作后，对列上数字的值的影响 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Thu, 24 Jul 2014 23:44:44 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-07-24:/cf-447d.html</guid><category>codeforces</category><category>algorithm</category><category>算法</category><category>题解</category></item><item><title>CPU cache引发的性能血案</title><link>http://wizmann.tk/cpu-cache-miss.html</link><description>&lt;p&gt;在__&lt;a href="http://evol128.is-programmer.com/posts/35453.html"&gt;为什么转置一个512x512的矩阵，会比513x513的矩阵慢很多？&lt;/a&gt;__一文中，作者引用了一个矩阵转置的例子，来讲解由于CPU cache的失效而带来的性能损失。&lt;/p&gt;
&lt;p&gt;上面的文章对问题的解释与讨论都非常的透彻。我的这篇文章只是对上面文章的一篇读后感和实验报告。就酱。&lt;/p&gt;
&lt;h2&gt;CPU cache 之 组相联&lt;/h2&gt;
&lt;p&gt;&lt;img alt="组相联" src="http://wizmann-tk-pic.u.qiniudn.com/blog-cpu-cache-2-way-set-assosiate.jpg"&gt;&lt;/p&gt;
&lt;p&gt;组相联的实现和原理不必再赘述了。我想讨论的是，如何在编程中优化CPU的cache性能。&lt;/p&gt;
&lt;h2&gt;查看CPU信息&lt;/h2&gt;
&lt;p&gt;我的系统是Ubuntu 12.04，CPU是i5-3230M。（屌丝机 :D)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wizmann@Wichmann:~$ ls /sys/devices/system/cpu/cpu0/cache/index0/
coherency_line_size  physical_line_partition  size
level                shared_cpu_list          type
number_of_sets       shared_cpu_map           ways_of_associativity
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用cat命令查看文件内容，可以获得CPU L1 cache的一些信息。&lt;/p&gt;
&lt;table class="table table-striped-white table-bordered"&gt;
&lt;thead&gt;
&lt;tr&gt;
 &lt;th&gt;Key&lt;/th&gt;
 &lt;th&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
 &lt;td&gt;level …&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sun, 20 Jul 2014 00:18:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-07-20:/cpu-cache-miss.html</guid><category>cpu</category><category>cache</category><category>profile</category><category>valgrind</category><category>cachegrind</category></item><item><title>玩玩算法题1：Sherlock and Queries</title><link>http://wizmann.tk/interview-problem-1-sherlock-and-queries.html</link><description>&lt;h2&gt;题目大意&lt;/h2&gt;
&lt;p&gt;给你三个数组:A[N], B[M], C[M]。让你按如下pseudo-code给出的规则计算，求出最终A[N]每一项的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for i = 1 to M do
    for j = 1 to N do
        if j % B[i] == 0 then
            A[j] = A[j] * C[i]
        endif
    end do
end do
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;数据范围&lt;/h2&gt;
&lt;p&gt;1≤ N,M ≤ 10^5 &lt;/p&gt;
&lt;p&gt;1 ≤ B[i …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sat, 19 Jul 2014 11:00:38 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-07-19:/interview-problem-1-sherlock-and-queries.html</guid><category>algorithm</category><category>interview</category></item><item><title>Codeforces Round #253 Tutorial</title><link>http://wizmann.tk/cf-253.html</link><description>&lt;hr&gt;
&lt;h2&gt;443A - Anton and Letters&lt;/h2&gt;
&lt;p&gt;Simple and easy, solved by two lines of python code.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ls&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="nb"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ls&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;443B - Kolya and Tandem Repeat&lt;/h2&gt;
&lt;p&gt;Brute force. Just enumerate the beginning and the end of the substring, and …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sat, 21 Jun 2014 19:24:37 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-06-21:/cf-253.html</guid><category>codeforces</category><category>algorithm</category></item><item><title>A simple problem - World at War</title><link>http://wizmann.tk/world-at-war.html</link><description>&lt;h2&gt;Background&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;This problem is from the book "&lt;a href="http://book.douban.com/subject/19952400/"&gt;Algorithm 4th edition&lt;/a&gt;" (Exersise 4.1.10)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There are N cities and M undirected roads between those cities. People can travel to any city along the roads.&lt;/p&gt;
&lt;p&gt;One day, a war breaks out. Our cities are under attack! As we can't defend all …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Thu, 12 Jun 2014 17:42:51 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-06-12:/world-at-war.html</guid><category>algorithm</category><category>interview</category><category>graph</category></item><item><title>How to implement a queue with stack(s)?</title><link>http://wizmann.tk/implement-queue-with-stacks.html</link><description>&lt;p&gt;This problem is from the book &lt;a href="http://book.douban.com/subject/19952400/"&gt;&lt;em&gt;Algorithms, 4th Edition&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Queue with three stacks. Implement a queue with three stacks so that each queue operation takes a constant (worst-case) number of stack operations. &lt;/p&gt;
&lt;p&gt;Warning : high degree of difficulty.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When I search the Internet to find a solution, I find varieties of …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Tue, 20 May 2014 13:23:03 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-05-20:/implement-queue-with-stacks.html</guid><category>algorithm</category><category>stack</category><category>queue</category></item><item><title>逗比带你读论文之Barrier</title><link>http://wizmann.tk/read-paper-barrier.html</link><description>&lt;p&gt;&lt;img alt="知识共享许可协议" src="http://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;逗比带你读论文之Barrier&lt;/em&gt; 由 &lt;a href="http://wizmann.tk"&gt;Wizmann&lt;/a&gt; 创作&lt;/p&gt;
&lt;p&gt;采用 &lt;a href="http://creativecommons.org/licenses/by-nc-sa/4.0/"&gt;知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
&lt;h2&gt;原文地址&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://ridiculousfish.com/blog/posts/barrier.html"&gt;Barrier February 17th, 2007&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;前言：我艹！好多核！&lt;/h2&gt;
&lt;p&gt;虽然80核心的浮点数运算巨兽离我们还有些遥远，但是多核处理器已经走进了我们的生活。&lt;/p&gt;
&lt;p&gt;其实多核处理器已经不是新鲜名词了，在Power Macintosh 9500中，就使用了多核处理器。&lt;/p&gt;
&lt;p&gt;现在让我们深入了理解一下多核心处理器吧。&lt;/p&gt;
&lt;h2&gt;线程技术&lt;/h2&gt;
&lt;h3&gt;一些名词定义&lt;/h3&gt;
&lt;h4&gt;线程&lt;/h4&gt;
&lt;p&gt;线程只是 &lt;strong&gt;抢占调度的&lt;/strong&gt;（pre-emptively scheduled） &lt;strong&gt;共享地址空间的&lt;/strong&gt; 执行上下文。&lt;/p&gt;
&lt;h4&gt;多线程&lt;/h4&gt;
&lt;p&gt;用来简化控制流和绕开阻塞的系统调用的方法，并非用来实现程序的并行化&lt;/p&gt;
&lt;h4&gt;并发多线程&lt;/h4&gt;
&lt;p&gt;在物理上并发的线程，用来利用多核处理器来优化系统性能&lt;/p&gt;
&lt;h3&gt;为什么“并发多线程”是个神坑&lt;/h3&gt;
&lt;p&gt;人人都在说”并发多线程“是个神坑，但这种老生常谈并不是因为自然原因 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Thu, 08 May 2014 19:05:26 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-05-08:/read-paper-barrier.html</guid><category>cpp</category><category>memory-barrier</category><category>asm</category><category>multiprocess</category><category>multithread</category><category>thread</category><category>cocurrency</category></item><item><title>Codeforces Round #242 (Div. 2) Tutorials and Solutions</title><link>http://wizmann.tk/cf-242-div-2.html</link><description>&lt;h2&gt;A. Squats&lt;/h2&gt;
&lt;p&gt;Trun &lt;code&gt;x =&amp;gt; X&lt;/code&gt; or &lt;code&gt;X =&amp;gt; x&lt;/code&gt; to make the number of 'x' is equal to the number of 'X'.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;hamsters&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;

&lt;span class="n"&gt;sits&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hamsters&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;stands&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hamsters&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;X&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;sits&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;stands&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hamsters&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;sits&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;stands …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Wed, 30 Apr 2014 17:39:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-04-30:/cf-242-div-2.html</guid><category>codeforces</category><category>algorithm</category><category>算法</category><category>题解</category></item><item><title>Codeforces Round #240 (Div. 2) Tutorials and Solutions(incomplete and incorrect)</title><link>http://wizmann.tk/cf-240-div-2.html</link><description>&lt;h2&gt;Overview&lt;/h2&gt;
&lt;p&gt;It has been months that I didn't participate in the contest on CF, now I'm back. :)&lt;/p&gt;
&lt;p&gt;This round of contest makes me confused that the problem B and C is a little bit too twisted, if you can't catch the vital point, you will get a lot of WAs …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Tue, 08 Apr 2014 14:39:11 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-04-08:/cf-240-div-2.html</guid><category>codeforces</category><category>algorithm</category><category>算法</category><category>题解</category></item><item><title>"alloca" vs "placement new"</title><link>http://wizmann.tk/alloca-vs-placement-new.html</link><description>&lt;h2&gt;WHAT?!&lt;/h2&gt;
&lt;p&gt;For most time, we use &lt;code&gt;malloc&lt;/code&gt; or &lt;code&gt;new&lt;/code&gt; for memory allocation, which will get it on &lt;em&gt;heap&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;However, access memory on &lt;em&gt;heap&lt;/em&gt; is not as effective as the memory on &lt;em&gt;stack&lt;/em&gt;, because the heap is "free-floating region of memory". To the contrary, memory on &lt;em&gt;stack&lt;/em&gt; is managed by CPU …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Mon, 07 Apr 2014 21:08:59 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-04-07:/alloca-vs-placement-new.html</guid><category>cpp</category><category>memory</category><category>stack</category><category>heap</category><category>allocate</category><category>alloca</category><category>c++</category></item><item><title>Quartile and Normal Distribution</title><link>http://wizmann.tk/quartile-and-normal-distribution.html</link><description>&lt;h2&gt;What is Quartile?&lt;/h2&gt;
&lt;p&gt;Quartile is a concept of descriptive statics. The quartiles of a ranked data set are the three points that divide the data set into four equal groups, each group comprising a quarter of data.&lt;/p&gt;
&lt;h2&gt;Definitions&lt;/h2&gt;
&lt;h3&gt;first quartile (Q1)&lt;/h3&gt;
&lt;p&gt;First quartile, also known as lower quartile, splits off …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sun, 09 Mar 2014 22:44:15 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-03-09:/quartile-and-normal-distribution.html</guid><category>quartile</category><category>normal-distribution</category></item><item><title>破解节操的下限</title><link>http://wizmann.tk/moujiecao.html</link><description>&lt;h2&gt;啥？&lt;/h2&gt;
&lt;p&gt;&lt;img alt="节操精选" src="http://wizmann-tk-pic.u.qiniudn.com/blog-jiecao-icon.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://jiecao.fm/"&gt;节操精选&lt;/a&gt;是一个&lt;strong&gt;没有下限&lt;/strong&gt;的文字图片聚合类移动应用，现在支持Android/iOS移动平台。&lt;/p&gt;
&lt;p&gt;&lt;img alt="界面" src="http://wizmann-tk-pic.u.qiniudn.com/blog-jiecao-ui.png"&gt;&lt;/p&gt;
&lt;p&gt;本人是一个非常懒的人，有电脑就不想碰手机。。。于是萌生了一个在PC端使用这个应用的想法。。。&lt;/p&gt;
&lt;h2&gt;HowTo&lt;/h2&gt;
&lt;p&gt;从界面上我们可以看出，这个App的逻辑其实比较简单。重要的部分有如下几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;获取CS通信协议&lt;strong&gt;（最重要）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;频道间切换（精选 - 热门 - 音频- 阅读）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;展示某一条精选&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在某一条精选中播放语音&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;获取通信协议&lt;/h2&gt;
&lt;p&gt;节操还是非常良心的！并没有在后台数据通信中进行任何加密的措施。&lt;/p&gt;
&lt;p&gt;抓包工具我使用的是在Windows环境下的&lt;a href="http://www.telerik.com/fiddler"&gt;Fiddler&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这个工具可以建立一个HTTP代理，手机通过代理上网，在电脑上就可以截获所有的数据包进行分析。&lt;/p&gt;
&lt;p&gt;在Linux下，可以使用TinyProxy + Wireshark进行抓包，不过配置小麻烦。不过我一直是在Windows下抓包，然后在Linux下做分析和开发的。=。=。。。&lt;/p&gt;
&lt;p&gt;图就不上了，如果大家有兴趣自己来搞的话，可以抓来试试。&lt;/p&gt;
&lt;p&gt;简而言之，我们从HTTP包中的&lt;code&gt;Content-type&lt;/code&gt;字段中，发现了我们想要的信息 —— &lt;code&gt;application/xprotobuf&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我去！真良心～&lt;/p&gt;
&lt;h3&gt;Protobuf简介 …&lt;/h3&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Tue, 25 Feb 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-02-25:/moujiecao.html</guid><category>crack</category><category>android</category><category>app</category><category>chrome-extension</category><category>protobuf</category><category>angularjs</category></item><item><title>GeoHash算法</title><link>http://wizmann.tk/geo-hash-algorithm.html</link><description>&lt;h2&gt;GeoHash&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Geohash is a latitude/longitude geocode system invented by Gustavo Niemeyer when writing the web service at geohash.org, and put into the public domain. It is a hierarchical spatial data structure which subdivides space into buckets of grid shape.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单说，GeoHash是一个将经纬度信息编码成一个string的算法。从而便于储存、查找。&lt;/p&gt;
&lt;h2&gt;GeoHash算法的步骤&lt;/h2&gt;
&lt;p&gt;GeoHash对经度纬度分别编码，原理是迭代做二分，进而逼近真实值。&lt;/p&gt;
&lt;p&gt;我们以纬度举例 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Tue, 04 Feb 2014 00:10:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-02-04:/geo-hash-algorithm.html</guid><category>GeoHash</category><category>POI</category><category>压缩</category><category>索引</category></item><item><title>如何判断一个网站的地理信息</title><link>http://wizmann.tk/find-the-geo-location-of-a-host.html</link><description>&lt;h2&gt;啥？&lt;/h2&gt;
&lt;p&gt;面试题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有一个网站，如何判断这个网站的地理信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;方法&lt;/h2&gt;
&lt;h3&gt;使用反向DNS&lt;/h3&gt;
&lt;p&gt;当我们只有网站的IP地址时，我们可以使用&lt;strong&gt;反向DNS&lt;/strong&gt;来获得这个IP地址对应的域名。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;反向域名解析，Reverse DNS。反向域名解析与通常的正向域名解析相反，提供IP地址到域名的对应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以使用&lt;code&gt;dig -x&lt;/code&gt;来进行查询&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ dig -x 75.126.43.235

&lt;span class="p"&gt;;&lt;/span&gt; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.8.1-P1 &amp;lt;&amp;lt;&amp;gt;&amp;gt; -x 75.126.43.235
&lt;span class="p"&gt;;;&lt;/span&gt; global options: +cmd
&lt;span class="p"&gt;;;&lt;/span&gt; Got answer:
&lt;span class="p"&gt;;;&lt;/span&gt; -&amp;gt;&amp;gt;HEADER&lt;span class="s"&gt;&amp;lt;&amp;lt;- opco&lt;/span&gt;de: QUERY, status: NOERROR, id: 26688
&lt;span class="p"&gt;;;&lt;/span&gt; flags: qr rd …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Fri, 24 Jan 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-01-24:/find-the-geo-location-of-a-host.html</guid><category>面试</category></item><item><title>Codeforces Round #223 (Div. 2) 不完全不正确题解</title><link>http://wizmann.tk/cf-223-div-2.html</link><description>&lt;p&gt;由于大号已经进Div. 1了，所以接下来的几场Div. 2都是用小号做的。&lt;/p&gt;
&lt;p&gt;等有实力切D题了，再去打一区。（弱&lt;/p&gt;
&lt;p&gt;事情一直很多，所以题解落后了好久才发。&lt;/p&gt;
&lt;h2&gt;A. Sereja and Dima&lt;/h2&gt;
&lt;p&gt;纯模拟，Python随便搞&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;pokers&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;

&lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;pokers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pokers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
        &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;pokers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;pokers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;pokers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sat, 18 Jan 2014 14:47:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-01-18:/cf-223-div-2.html</guid><category>codeforces</category><category>algorithm</category><category>算法</category><category>题解</category></item><item><title>用Misaka做为pelican的Markdown解析器</title><link>http://wizmann.tk/misaka-pelican.html</link><description>&lt;h2&gt;为啥？&lt;/h2&gt;
&lt;p&gt;Pelican内置&lt;a href="http://pythonhosted.org/Markdown/"&gt;python-markdown&lt;/a&gt;做为默认解析器，用来将用户的&lt;code&gt;Markdown&lt;/code&gt;格式的文章转为网页格式展示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然而&lt;/strong&gt;，&lt;code&gt;python-markdown&lt;/code&gt;模块的解析逻辑有严重的Bug。例如一个&lt;code&gt;未标明语言的代码块&lt;/code&gt;会被标出很多莫名奇妙的错误；还有&lt;code&gt;C++&lt;/code&gt;中的指针符号&lt;code&gt;*&lt;/code&gt;会被解析为斜体的符号&lt;code&gt;*SomeText*&lt;/code&gt;，在代码块中会产生大量和语法高亮无关的斜体字。&lt;/p&gt;
&lt;p&gt;在网上寻找了很久的答案，终于找到了一篇&lt;a href="http://qiita.com/5t111111/items/4614b207f3942d05e55c"&gt;日文博客&lt;/a&gt;，其中讲到了使用&lt;a href="http://misaka.61924.nl/"&gt;misaka&lt;/a&gt;来替换&lt;code&gt;python-markdown&lt;/code&gt;来解析日志。&lt;/p&gt;
&lt;h2&gt;两难的Metadata&lt;/h2&gt;
&lt;p&gt;我使用了上文提到的日志中的方法来替换解析器，效果拔群，日志中的解析问题完全解决了。但是日志中的&lt;code&gt;Metadata&lt;/code&gt;并没有被隐藏，而是显示在了日志的最前面，非常影响心情（强迫症？）。&lt;/p&gt;
&lt;p&gt;于是我分析了解析模块的代码。原来的解析模块使用了&lt;code&gt;python-markdown&lt;/code&gt;的一个处理&lt;code&gt;Metadata&lt;/code&gt;的&lt;a href="https://github.com/waylan/Python-Markdown/blob/master/markdown/extensions/meta.py"&gt;扩展&lt;/a&gt;，用来解析&lt;code&gt;Metadata&lt;/code&gt;，并从正文中删除这一部分。&lt;/p&gt;
&lt;p&gt;但是&lt;code&gt;Misaka&lt;/code&gt;并不支持这种语法 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Thu, 09 Jan 2014 14:55:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-01-09:/misaka-pelican.html</guid><category>markdown</category><category>misaka</category><category>pelican</category><category>糙快猛</category><category>metadata</category></item><item><title>读书 - 《Head first 设计模式》</title><link>http://wizmann.tk/read-head-first-design-pattern.html</link><description>&lt;p&gt;&lt;img alt="Head first设计模式" src="http://img5.douban.com/lpic/s2686916.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/2243615/"&gt;豆瓣读书&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;为什么读这本书&lt;/h2&gt;
&lt;p&gt;在面XX家的时候，被问过一个设计模式问题。当时连面向对象都搞不懂，更不用说设计模式。&lt;/p&gt;
&lt;p&gt;于是入了“四人帮”的&lt;a href="http://book.douban.com/subject/1052241/"&gt;设计模式&lt;/a&gt;来看，被里面的内容彻底搞晕。然后只能找了这本看起来很娱乐化的书来读。&lt;/p&gt;
&lt;p&gt;这本书大概有600多页，比“四人帮”书厚很多。一个原因是这本书是“范例驱动”的，包含很多“项目”背景介绍，以及实现思路；第二个原因是，这本书的示例代码用的是&lt;strong&gt;Java&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;（笑，不黑了好嘛。。。&lt;/p&gt;
&lt;h2&gt;为什么要设计模式&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;这世界唯一不变的，就是变化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（没有逼格的人连名人名言都引用不好。。。&lt;/p&gt;
&lt;p&gt;我们的代码总是需要不断的改变来适应现实世界中不断的变化。（烧死那个PM！）&lt;/p&gt;
&lt;p&gt;我们需要一种&lt;code&gt;对代码影响最小&lt;/code&gt;的方式来修改软件以适应变化。这就是我们使用设计模式的原因。&lt;/p&gt;
&lt;h2&gt;“内隐知识”&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;设计模式有了名字，人们就可以认识到它的存在。对于没有名字的东西，人们几乎不可能认识到它的存在，并对之进行讨论。这种不能用语言表达的知识我们称之为内隐知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实我们在写程序的时候，或多或少都用到了“设计模式”，只是我们没有意识到而已 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Fri, 03 Jan 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-01-03:/read-head-first-design-pattern.html</guid><category>读书</category><category>head-first</category><category>设计模式</category></item><item><title>匈牙利算法</title><link>http://wizmann.tk/hungary-algorithm.html</link><description>&lt;h2&gt;概念&lt;/h2&gt;
&lt;h3&gt;交错路&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;交错路：设P是图G的一条路，如果P的任意两条相邻的边一定是一条属于M而另一条不属于M，就称P是一条交错路。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通俗点来说，就是把一个图中的路径染成红黑两种。然后找出一条路，使这条路&lt;strong&gt;红黑交错&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注：交错路是无向图，图中的箭头只是为了便于观察。&lt;/p&gt;
&lt;p&gt;例如下图中的：&lt;code&gt;(3) -&amp;gt; (2) -&amp;gt; (1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图1" src="http://wizmann-tk-pic.u.qiniudn.com/blog-hungary-1.png"&gt;&lt;/p&gt;
&lt;h3&gt;从端点扩张交错路&lt;/h3&gt;
&lt;p&gt;假设我们已经有一个红黑交错路&lt;code&gt;P&lt;/code&gt;，其端点为&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;，其路径被标记为&lt;code&gt;黑红&lt;/code&gt;。此时，我们向&lt;code&gt;P&lt;/code&gt;中的一个端点（假设为&lt;code&gt;A&lt;/code&gt;）加入一条边&lt;code&gt;T&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;此时我们有&lt;code&gt;边T + 交错路P（黑红）&lt;/code&gt;。当我们将边&lt;code&gt;T&lt;/code&gt;标记为&lt;code&gt;黑色&lt;/code&gt;时，我们就扩展了交错路&lt;code&gt;P&lt;/code&gt;。
如果我们要保持红黑交错路的&lt;strong&gt;性质&lt;/strong&gt;。则我们必须将边&lt;code&gt;T …&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Wed, 01 Jan 2014 22:01:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2014-01-01:/hungary-algorithm.html</guid><category>algorithm</category></item><item><title>Codeforces 3C - Tic-tac-toe</title><link>http://wizmann.tk/cf-3c-tic-tac-toe.html</link><description>&lt;h2&gt;啥？&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://codeforces.com/problemset/problem/3/C"&gt;Tic-tac-toe&lt;/a&gt;是我很久之前在CF上做的一道题。非常考细心的模拟题。&lt;/p&gt;
&lt;p&gt;最近有同学和我讨论过类似的问题。于是拿出来重新做一遍。练练手。&lt;/p&gt;
&lt;h2&gt;原题做法&lt;/h2&gt;
&lt;p&gt;没有任何“算法”成分。纯模拟。&lt;/p&gt;
&lt;p&gt;又由于数据量实在是太小（3 × 3的矩阵），所以只要是思路正确。代码怎么写都能过。&lt;/p&gt;
&lt;p&gt;于是在这里就不赘述。手快的众位10分钟切此题无压力。&lt;/p&gt;
&lt;h2&gt;What's new?&lt;/h2&gt;
&lt;p&gt;如果我们扩展一下这个问题。如果让你设计一个Tic-tac-toe的对战系统（人机对战、人人对战等），你将如何设计？&lt;/p&gt;
&lt;h2&gt;the STATE pattern&lt;/h2&gt;
&lt;p&gt;我们可以看出，这个对战系统其实可以用一个状态机来表示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="http://wizmann-tk-pic.u.qiniudn.com/blog-tick-tac-toe.png" src="http://wizmann-tk-pic.u.qiniudn.com/blog-tick-tac-toe.png"&gt;&lt;/p&gt;
&lt;p&gt;于是我们的对战系统也可以写成一个状态机的模式。&lt;/p&gt;
&lt;h2&gt;show me the CODE&lt;/h2&gt;
&lt;p&gt;首先我们声明一个&lt;code&gt;State&lt;/code&gt;接口类型。&lt;/p&gt;
&lt;p&gt;由于Tic-tac-toe游戏只有两种操作类型：&lt;code&gt;P1 move&lt;/code&gt;和&lt;code&gt;P2 move&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所以我们的接口就很简单。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;State&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;State …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sun, 29 Dec 2013 20:23:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2013-12-29:/cf-3c-tic-tac-toe.html</guid><category>codeforces</category><category>algorithm</category><category>算法</category><category>设计模式</category></item><item><title>How to "Rotate Image"?</title><link>http://wizmann.tk/how-to-rotate-image-leetcode.html</link><description>&lt;h2&gt;啥？&lt;/h2&gt;
&lt;p&gt;原题&lt;a href="http://oj.leetcode.com/problems/rotate-image/"&gt;戳我&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Rotate Image&lt;/p&gt;
&lt;p&gt;You are given an n x n 2D matrix representing an image.&lt;/p&gt;
&lt;p&gt;Rotate the image by 90 degrees (clockwise).&lt;/p&gt;
&lt;p&gt;Follow up:&lt;/p&gt;
&lt;p&gt;Could you do this in-place?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="rotate-image" src="http://wizmann-tk-pic.u.qiniudn.com/blog-rotate-image-leetcode.png"&gt;&lt;/p&gt;
&lt;p&gt;当然，矩阵中的数字&lt;strong&gt;不一定&lt;/strong&gt;是规律的。&lt;/p&gt;
&lt;h2&gt;为什么要提出这个问题&lt;/h2&gt;
&lt;p&gt;自觉是一个&lt;strong&gt;不聪明&lt;/strong&gt;的人（双低。。。&amp;lt;(=＠_＠;=)?&amp;gt;）。&lt;/p&gt;
&lt;p&gt;别人一下子就想明白的事，在我这里要计算好几个来回。&lt;/p&gt;
&lt;p&gt;所以努力想找到一个思维方法去弥补这个不足。&lt;/p&gt;
&lt;p&gt;就以这题为例，如何使用简单、直接的方法，迅速正确的找出变化的映射规律。&lt;/p&gt;
&lt;h2&gt;初步思路 …&lt;/h2&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sat, 28 Dec 2013 14:42:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2013-12-28:/how-to-rotate-image-leetcode.html</guid><category>Leetcode</category><category>algorithm</category><category>思维</category></item><item><title>Codeforces Round #221 (Div. 2)不完全不正确题解</title><link>http://wizmann.tk/cf-221-div-2.html</link><description>&lt;h2&gt;A. Lever&lt;/h2&gt;
&lt;p&gt;水题，杠杆原理。&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;^&lt;/code&gt;把字符串分割开。然后分别计算两边的重量即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#Result: Dec 24, 2013 6:04:41 PM    Wizmann  A - Lever   Python 2   Accepted     312 ms  4200 KB&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;calc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;
        &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;

&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;raw_input …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Wed, 25 Dec 2013 19:05:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2013-12-25:/cf-221-div-2.html</guid><category>codeforces</category><category>algorithm</category><category>算法</category><category>题解</category></item><item><title>自己动手搭建第三方的Codeforces CDN</title><link>http://wizmann.tk/third-party-codeforces-cdn.html</link><description>&lt;h2&gt;啥？&lt;/h2&gt;
&lt;p&gt;校园网上CF那叫一个卡。&lt;/p&gt;
&lt;p&gt;原因是什么呢？ 因为codeforces大量的使用了ajax技术，所以引用了很多js/css文件，并且引用的位置位于页面之前。&lt;/p&gt;
&lt;p&gt;这就造成了，我们在上CF的时候，其实页面内容已经读取出来了。但是因为js/css文件没有加载完成，所以页面还是一片空白。&lt;/p&gt;
&lt;h2&gt;解决方案&lt;/h2&gt;
&lt;p&gt;由于js/css/img文件都是所谓的&lt;code&gt;静态&lt;/code&gt;文件，那么我们可以缓存这些文件到一个访问速度快的网络上来。&lt;/p&gt;
&lt;p&gt;这就是CDN技术。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是俄罗斯人那边没有做CDN，或者他们的CDN距离天朝实在是太远了。&lt;/p&gt;
&lt;p&gt;所以我们只好手动缓存这些静态文件到七牛云上，使用七牛的CDN技术来加速我们的访问了。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.qiniu.com/"&gt;七牛云&lt;/a&gt;为个人用户提供了10G存储空间和每月10G流量，这对于我们缓存一个网站的静态文件来说，已经足富裕了。根据我现在的使用状况，所有静态文件加在一起大概在3M左右，搭建这样一个免费CDN可以供十几个人使用。&lt;/p&gt;
&lt;h2&gt;设计架构&lt;/h2&gt;
&lt;p&gt;我们使用&lt;code&gt;CS模式&lt;/code&gt;来完成这个网站加速的任务。&lt;/p&gt;
&lt;p&gt;Server端当然就是七牛云啦。复杂的任务都交给了工程师们完成，我们只需要声明需要缓存&lt;code&gt;codeforces.com …&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sat, 14 Dec 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2013-12-14:/third-party-codeforces-cdn.html</guid><category>codeforces</category><category>chrome-extension</category><category>useless</category></item><item><title>在Google面试之后想到的</title><link>http://wizmann.tk/after-google-interview.html</link><description>&lt;p&gt;&lt;img alt="思维导图" src="http://wizmann-tk-pic.u.qiniudn.com/about-google-interview-tiny.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wizmann-tk-pic.u.qiniudn.com/about-google-interview.png"&gt;戳我看高清无码大图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外，面试过程中没被吓尿也算是我心理比较强大吧。&lt;/p&gt;
&lt;p&gt;#屌丝心态#。。。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Wed, 11 Dec 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2013-12-11:/after-google-interview.html</guid><category>闲聊</category></item><item><title>Codeforces Round #218 (Div. 2)不完全不正确题解</title><link>http://wizmann.tk/cf-218-div-2.html</link><description>&lt;h3&gt;A. K-Periodic Array&lt;/h3&gt;
&lt;p&gt;将Array切片，然后按位统计某一位上1的个数C(1)和2的个数C(2)。然后在这一位上的操作数就为M = min(C(1), C(2))。&lt;/p&gt;
&lt;p&gt;简单题&lt;/p&gt;
&lt;h3&gt;B. Fox Dividing Cheese&lt;/h3&gt;
&lt;p&gt;傻逼才错的题，不幸中枪。&lt;/p&gt;
&lt;p&gt;不想多说了，直接看代码吧。手贱不是病，贱起来要人命。&lt;/p&gt;
&lt;h3&gt;C. Hamburgers&lt;/h3&gt;
&lt;p&gt;模拟 + 二分。&lt;/p&gt;
&lt;p&gt;和CJL还讨论过这题的纯模拟做法，看了半天代码没找到问题。于是刚才用Python自己实现了一个，在代码正确的情况下，没有WA，但是T在了22组上。&lt;/p&gt;
&lt;p&gt;所以这题最好使用二分，如果用模拟的话，需要考虑各种情况。代码见下，细节上注意就好。&lt;/p&gt;
&lt;h3&gt;D. Vessels&lt;/h3&gt;
&lt;p&gt;这题得好好讲一下～比赛时做出来了好得意～&lt;/p&gt;
&lt;p&gt;&lt;img alt="Vessels" src="http://wizmann-tk-pic.u.qiniudn.com/blog-cf-218-div-2-d-vessels.png"&gt;&lt;/p&gt;
&lt;p&gt;题意是给出一组层层叠的容器，每一个容器都有自己的容量。然后我们向某些容器里灌水，如果水的体积超过了某个容器的容量，则剩余的水溢出到下一个容器中。最后一个容器溢出的水会落到地面上 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Mon, 09 Dec 2013 23:02:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2013-12-09:/cf-218-div-2.html</guid><category>codeforces</category><category>algorithm</category><category>算法</category><category>题解</category></item><item><title>使用新类型创建更人性化的代码</title><link>http://wizmann.tk/humanity-code-with-new-classes.html</link><description>&lt;h2&gt;啥？&lt;/h2&gt;
&lt;p&gt;这篇文章讨论了如何通过新建并非”必要“的新类型，来产生更人性化的C++代码。&lt;/p&gt;
&lt;p&gt;关键词：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RAII&lt;/li&gt;
&lt;li&gt;智能指针&lt;/li&gt;
&lt;li&gt;接口友好&lt;/li&gt;
&lt;li&gt;模板&lt;/li&gt;
&lt;li&gt;模板特化&lt;/li&gt;
&lt;li&gt;依赖编译器的缺省行为&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于C++的艺术，我只是个入门者。如果文章中有什么问题，欢迎大家指出，我会及时进行修改。&lt;/p&gt;
&lt;h2&gt;一个友好的互斥锁&lt;/h2&gt;
&lt;h3&gt;互斥锁的定义&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;互斥锁（英语：英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;如何使用互斥锁&lt;/h3&gt;
&lt;p&gt;这里只做最简单的示范。具体的使用方法和原理不在本文的讨论范围之内。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;pthread.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyIntArray …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Mon, 09 Dec 2013 15:01:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2013-12-09:/humanity-code-with-new-classes.html</guid><category>cpp</category></item><item><title>Yunfile下载破解[废弃]</title><link>http://wizmann.tk/yunfile-cracker.html</link><description>&lt;h2&gt;废弃原因&lt;/h2&gt;
&lt;p&gt;因为Yunfile现在开始限IP + 无限抽风，所以插件已经废弃不用了。现在也没找到解决方法。\o&amp;lt;(=╯□╰=)&amp;gt;o&lt;/p&gt;
&lt;h2&gt;啥？&lt;/h2&gt;
&lt;p&gt;大家都知道&lt;code&gt;Yunfile&lt;/code&gt;是做什么的咩？反正我是不知道。。。&lt;/p&gt;
&lt;p&gt;今天下午无聊，写了一个yunfile下载的破解插件。&lt;/p&gt;
&lt;h2&gt;功能：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;非会员跳过下载等待的30s（或者更长时间）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载页面不会报“因长时间未操作，需要重新下载”的错误&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里感谢&lt;strong&gt;luacloud&lt;/strong&gt;的&lt;a href="http://www.luacloud.com/2012/crack-yunfile-network-disk-30-wait-for-restrictions.html"&gt;博文&lt;/a&gt;，为插件的编写提供了原型。&lt;/p&gt;
&lt;h2&gt;具体功能实现：&lt;/h2&gt;
&lt;h3&gt;跳过等待&lt;/h3&gt;
&lt;p&gt;在上面引用的博文里面有说，就是强制执行页面中的js，实现跳转。&lt;/p&gt;
&lt;p&gt;还做了一个DOM修改，变成现在这种很漂漂的样子～～&lt;/p&gt;
&lt;p&gt;&lt;img alt="Yunfile-Craker-1" src="http://wizmann-tk-pic.u.qiniudn.com/yunfile-craker-1.png"&gt;&lt;/p&gt;
&lt;h3&gt;忽略超时错误&lt;/h3&gt;
&lt;p&gt;覆盖了下载函数，跳过超时判断。&lt;/p&gt;
&lt;h2&gt;现有问题&lt;/h2&gt;
&lt;p&gt;在一些情况下，点击下载按钮会返回到下载页。&lt;/p&gt;
&lt;p&gt;虽然我们不需要再等30s了，但是还是很烦。&lt;/p&gt;
&lt;p&gt;也有我有机会修复这个问题。&lt;/p&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;p&gt;代码在&lt;a href="https://github.com/Wizmann/Utils/tree/master/Chrome-extension/yunfile-cracker"&gt;这里&lt;/a&gt;呀～&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Mon, 02 Dec 2013 21:16:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2013-12-02:/yunfile-cracker.html</guid><category>创造力</category><category>Yunfile</category><category>Chrome-Extension</category></item><item><title>Tick-tick</title><link>http://wizmann.tk/tick-tick.html</link><description>&lt;p&gt;Go back to work！&lt;/p&gt;
&lt;p&gt;&lt;img alt="Big brother is watching you!" src="http://wizmann-tk-pic.u.qiniudn.com/blog-ticktick-big-brother.jpg"&gt;&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Mon, 02 Dec 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2013-12-02:/tick-tick.html</guid><category>闲聊</category><category>创造力</category></item><item><title>機器學習基石 - PLA算法初步</title><link>http://wizmann.tk/ml-foundations-pla.html</link><description>&lt;h2&gt;什么是PLA算法&lt;/h2&gt;
&lt;p&gt;PLA = Perceptrons Learning Alogrithm&lt;/p&gt;
&lt;p&gt;WikiPedia上有一个大概的历史背景介绍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;感知机（英语：Perceptron）是Frank Rosenblatt在1957年就职于Cornell航空实验室(Cornell Aeronautical Laboratory)时所发明的一种人工神经网络。它可以被视为一种最简单形式的前馈式人工神经网络，是一种二元线性分类器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;PLA算法的原理&lt;/h2&gt;
&lt;p&gt;&lt;img alt="感知机示意图" src="http://wizmann-tk-pic.u.qiniudn.com/blog-perceptron-Ncell.png"&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于每种输入值(1 - D)，我们计算一个权重。当前神经元的总激发值(a)就等于每种输入值(x)乘以权重(w)之和。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由此我们就可以推导出公式如下。&lt;/p&gt;
&lt;p&gt;&lt;img alt="neuron sum" src="http://wizmann-tk-pic.u.qiniudn.com/blog-perceptron-formula-1.jpg"&gt;&lt;/p&gt;
&lt;p&gt;我们可以为这个“神经元”的激发值设定一个阈值&lt;code&gt;threshold&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;a &amp;gt; threshold&lt;/code&gt;，则判定输入为正例。
如果 &lt;code&gt;a &amp;lt; threshold&lt;/code&gt;，则判定输入为负例。
对于 &lt;code&gt;a == threshold&lt;/code&gt;的情况，认为是特殊情况，不予考虑。&lt;/p&gt;
&lt;p&gt;所以，我们的感知器分类器就可以得到以下式子 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Fri, 29 Nov 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2013-11-29:/ml-foundations-pla.html</guid><category>公开课</category><category>分类器</category></item><item><title>Linux内核中的少锁链表</title><link>http://wizmann.tk/linux-lockless-llist.html</link><description>&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;最近在stackexchange上看到一个问答，讨论我们常用的数据结构与算法在实际工程中的应用。(&lt;a href="http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed/19773#19773"&gt;戳我&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;我打算借助这个问答中的内容，以我比较熟悉的数据结构与算法为索引来阅读开源代码。&lt;/p&gt;
&lt;h1&gt;正文&lt;/h1&gt;
&lt;h2&gt;Talk is cheap&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Lock-less NULL terminated single linked list&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/mirrors/linux-2.6/blob/master/include/linux/llist.h"&gt;linux-2.6/include/linux/llist.h&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/mirrors/linux-2.6/blob/master/lib/llist.c"&gt;linux-2.6/lib/llist.c&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;知识准备&lt;/h2&gt;
&lt;h3&gt;volatile&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;volatile关键字声明的变量或对象通常拥有和优化和（或）多线程相关的特殊属性。&lt;/p&gt;
&lt;p&gt;通常，volatile关键字用来阻止（伪）编译器对那些它认为变量的值不能“被代码本身”改变的代码上执行任何优化。 &lt;/p&gt;
&lt;p&gt;如果不使用volatile关键字，编译器将假设当前程序是系统中唯一能改变这个值部分。 为了阻止编译器像上面那样优化代码，需要使用volatile关键字。&lt;/p&gt;
&lt;p&gt;From: http://zh.wikipedia.org/wiki/Volatile%E5 …&lt;/p&gt;&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Thu, 28 Nov 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2013-11-28:/linux-lockless-llist.html</guid><category>linux</category><category>lock-less</category><category>链表</category><category>并发编程</category></item><item><title>Codeforces Round #215 (Div. 2)不完全不正确题解</title><link>http://wizmann.tk/cf-215-div-2.html</link><description>&lt;h3&gt;A. Sereja and Coat Rack&lt;/h3&gt;
&lt;p&gt;傻逼才错的题。不幸中枪。&lt;/p&gt;
&lt;p&gt;没什么可说的。直接看代码就好。&lt;/p&gt;
&lt;h3&gt;B. Sereja and Suffixes&lt;/h3&gt;
&lt;p&gt;关键思想在于统计A[i...n-1]中有多少互不相同的数。&lt;/p&gt;
&lt;p&gt;使用离线思想，把查询按&lt;code&gt;greater&amp;lt;int&amp;gt;&lt;/code&gt;排序，然后使用Hash表进行统计，简单题。&lt;/p&gt;
&lt;h3&gt;C. Sereja and Algorithm&lt;/h3&gt;
&lt;p&gt;思路题。&lt;/p&gt;
&lt;p&gt;我们容易想到如果可以交换相邻两个字母的位置，我们就可以获得这个字符串所有的排列。&lt;/p&gt;
&lt;p&gt;所以我们只需要统计出A[i...j]中x, y, z的个数。&lt;/p&gt;
&lt;p&gt;然后进行排列。&lt;/p&gt;
&lt;p&gt;我们可以推出，稳定的排列（即可以使算法停下来的排列）只有如下几种情况。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;zy[xzy][xzy]...
xz[yxz][yxz]...
yx[zyx …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Wed, 27 Nov 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2013-11-27:/cf-215-div-2.html</guid><category>codeforces</category><category>algorithm</category><category>算法</category><category>题解</category></item><item><title>CSE351 - Lab 1: Manipulating Bits Using C</title><link>http://wizmann.tk/cse351-lab1.html</link><description>&lt;p&gt;今天做了CSE351 - Lab1，深深的感觉国外的计算机教学爆了我校一条街。&lt;/p&gt;
&lt;p&gt;以上是前言。&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;bitAnd &amp;amp; bitOr&lt;/h3&gt;
&lt;p&gt;德摩根定理的应用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* &lt;/span&gt;
&lt;span class="cm"&gt; * bitAnd - x&amp;amp;y using only ~ and | &lt;/span&gt;
&lt;span class="cm"&gt; *   Example: bitAnd(6, 5) = 4&lt;/span&gt;
&lt;span class="cm"&gt; *   Legal ops: ~ |&lt;/span&gt;
&lt;span class="cm"&gt; *   Max ops: 8&lt;/span&gt;
&lt;span class="cm"&gt; *   Rating: 1&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;bitAnd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* &lt;/span&gt;
&lt;span class="cm"&gt; * bitOr - x|y using only ~ and &amp;amp; &lt;/span&gt;
&lt;span class="cm"&gt; *   Example: bitOr(6, 5) = 7&lt;/span&gt;
&lt;span class="cm"&gt; *   Legal ops: ~ &amp;amp;&lt;/span&gt;
&lt;span class="cm"&gt; *   Max ops: 8 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Wed, 27 Nov 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2013-11-27:/cse351-lab1.html</guid><category>CSE351</category><category>公开课</category></item><item><title>CSE 351 - Hardware/Software Interface</title><link>http://wizmann.tk/Washington-University-CSE351.html</link><description>&lt;p&gt;开一门公开课，Washington University的Hardware/Software Interface。&lt;/p&gt;
&lt;p&gt;传说是很不错的计算机科学公开课。使用&lt;a href="http://book.douban.com/subject/5333562/"&gt;深入理解计算机系统&lt;/a&gt;做教材，正好是我要读的书，所以顺便听听课。&lt;/p&gt;
&lt;p&gt;豆瓣上有人写了&lt;a href="http://book.douban.com/review/6093947/"&gt;推荐&lt;/a&gt;，观点是这课虽然不错，但是比较浅。根据我现在的理解来说，确实比较浅，如果有不错的高级语言编程基础（C/C++/Java/Pascal等，脚本就算了），很多东西可以速推。&lt;/p&gt;
&lt;p&gt;接下来的一些日志会是这门课的作业、实验和感想。现在先挖个坑。慢慢填上。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;课程视频：&lt;a href="http://pan.baidu.com/wap/link?&amp;amp;shareid=3687486382&amp;amp;uk=2919707929&amp;amp;third=0&amp;amp;page=1"&gt;戳我&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;课程主页：&lt;a href="https://courses.cs.washington.edu/courses/cse351/13su/index.html"&gt;戳我&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Tue, 26 Nov 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2013-11-26:/Washington-University-CSE351.html</guid><category>公开课</category><category>计算机科学</category><category>CSE351</category></item><item><title>使用pip和virtuanenv</title><link>http://wizmann.tk/using-pip-and-virtualenv.html</link><description>&lt;p&gt;让我们从一个无聊的小段子开始。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"What’s pip?"&lt;/p&gt;
&lt;p&gt;"A python package manager"&lt;/p&gt;
&lt;p&gt;"How do I install it?"&lt;/p&gt;
&lt;p&gt;"easy_install pip"&lt;/p&gt;
&lt;p&gt;"What’s easy_install?"&lt;/p&gt;
&lt;p&gt;"A python package manager"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;pip和easy_install都是python的包管理工具，类似于ruby的gem以及nodejs的npm。&lt;/p&gt;
&lt;p&gt;而pip是easy_install的升级版，在这个&lt;a href="http://www.pip-installer.org/en/1.0.2/#pip-compared-to-easy-install"&gt;页面&lt;/a&gt;中提到了pip对于easy_install的升级。其中提到了一点非常重要。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pip is complementary with virtualenv, and it is encouraged that you use virtualenv to isolate your installation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果有同学不熟悉virtualenv，这里是一个小小的介绍。（以下翻译来自：&lt;a href="http://blogs.360.cn/blog/how-360-uses-python-1-virtualenv/"&gt;戳我 …&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Mon, 25 Nov 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2013-11-25:/using-pip-and-virtualenv.html</guid><category>python</category></item><item><title>Hello World</title><link>http://wizmann.tk/hello-world.html</link><description>&lt;p&gt;打算把博客迁到这里来了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Hello World&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wizmann</dc:creator><pubDate>Sun, 24 Nov 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:wizmann.tk,2013-11-24:/hello-world.html</guid><category>闲聊</category></item></channel></rss>